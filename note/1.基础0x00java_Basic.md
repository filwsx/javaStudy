//20211231 1709开始

# 0X00、导论

## 零、路线图

【苦海无涯，回头是岸】

基础：java语言，MySQL，JDBC，JavaWeb系列

框架：Spring5、SpringMVC、MyBatis3、MyBatis-Plus、SSM整合

工具：git/svn，maven/gradle，Eclipse/IDEA，Linux

微服务：Redis6、SpringBoot2，SpringCloud，Docker，k8s

内功1：JVM；数据结构，算法，设计模式；操作系统，计算机网络，组成原理，编译原理。

内功2：【全英文】面试技巧，读源码，看文档，Google

![屏幕截图 2022-02-02 153230](./assets/java/屏幕截图 2022-02-02 153230.png)

## 一、Java职业生涯

1. 如何选择编程语言：根据应用领域选择合适的，结合tiobe排行榜

2. Java应用领域：服务器后端，大数据，Android开发

3. java职业路线

![image-20211231173706063](./assets/java/image-20211231173706063.png)

![image-20211231173715256](./assets/java/image-20211231173715256.png)

## 二、Java初识

1.  java基础知识图解![image-20211231172006332](./assets/java/image-20211231172006332.png)
2.  Java基础课概述![image-20211231172155479](./assets/java/image-20211231172155479.png)
3.  编程学习经验：模仿好的代码，狂敲；**三分看，七分练**；![image-20211231173800076](./assets/java/image-20211231173800076.png)

## 三、计算机基础知识

1. 硬件部分

   1.1 冯诺依曼结构

   ​	![image-20211231173641505](./assets/java/image-20211231173641505.png)

   1.2 三大定律：摩尔定律（硬件提升速度）、安迪-比尔定律（软件吃硬件性能提升）、反摩尔定律（商业销售）

   1.3 CPU：Central Processing Unit，持久化存储：硬盘，bit语byte区分，内存

   1.4 操作系统

   1.5 万维网：B/S与C/S两种架构

2. 软件部分

   2.1 程序设计 = 数据结构 + 算法

   2.2 编程语言：机器语言，汇编语言，高级语言（面向过程，面向对象）

   2.3 交互方式：图形化GUI与命令行CLI

   2.4 Java初识：特点(面向对象、健壮性、跨平台性)，核心机制(jvm、垃圾收集)，发展史

   2.5 Java结构与运行机制

   ![image-20211231175109597](./assets/java/image-20211231175109597.png)

   ![image-20211231175151822](./assets/java/image-20211231175151822.png)

   2.6 开发环境搭建：略

   2.7 **Hello，World！**

   ```
   package com.filwsx.javabasics;
   public class HelloWorld {
   	public static void main(String[] args) {
   		System.out.println("你好啊，filwsx");
   	}
   }
   ```

   ![image-20211231175652530](./assets/java/image-20211231175652530.png)

​	2.8 Java注释(comment)与API(Application Programming Interface)

​	2.9 开发工具：记事本，eclipse，IDEA

# 0X01、基本语法

## 一、关键字与标识符

### 0. 关键字

| 用于定义数据类型的关键字           |            |           |              |          |        |
| ---------------------------------- | ---------- | --------- | ------------ | -------- | ------ |
| class                              | interface  | enum      | byte         | short    | int    |
| long                               | float      | double    | char         | boolean  | void   |
| 用于定义流程控制的关键字           |            |           |              |          |        |
| if                                 | else       | switch    | case         | default  |        |
| while                              | do         | for       | break        | continue | return |
| 用于定义访问权限修饰符的关键字     |            |           |              |          |        |
| private                            | protected  | public    |              |          |        |
| 用于定义类，函数变量修饰符的关键字 |            |           |              |          |        |
| abstract                           | final      | static    | synchronized |          |        |
| 用于定义类与之间关系的键字         |            |           |              |          |        |
| extends                            | implements |           |              |          |        |
| 用于定义建立实例及引，判断的关键字 |            |           |              |          |        |
| new                                | this       | super     | instanceof   |          |        |
| 用于异常处理的关键字               |            |           |              |          |        |
| try                                | catch      | finally   | throw        | throws   |        |
| 用于包的关键字                     |            |           |              |          |        |
| package                            | import     |           |              |          |        |
| 其他修饰符关键字                   |            |           |              |          |        |
| native                             | strictfp   | transient | volatile     | assert   |        |
| * 用于定义数据类型值的 字面值      |            |           |              |          |        |
| TRUE                               | FALSE      | null      |              |          |        |

### 1. 标识符

​	定义：对各种 变量 、 方法 和 类 等要素命名时使用的字符序列称为标识符

​	**规则：**

- 由 26 个英文字母大小写， 0 9 或 $ 组成
- 数字不可以开头。
- 不可以使用关键字和保留字，但能包含关键字和保留字。
- Java 中严格区分大小写，长度无限制。
- 标识符不能包含空格。

​	**规范：**

- 包名 ：多单词组成时所有字母都小写 xxxyyyzzz
- 类名、接口名 ：多单词组成时，所有单词的首字母大写 XxxYyyZzz
- 变量名、方法名 ：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写： xxxYyyZzz
- 常量名 ：所有字母都大写。多单词时每个单词用下划线连接 XXX_YYY_ZZZ

### 2. 变量

​	概念：存储在内存中，可变化的数据

​    作用：保存数据

​	用法：声明（语法： <数据类型>  <变量名称>；例如：int var;）和 赋值（语法：<变量名称 > = <值>;  例如： var = 10;）

​	分类：【按照类型】![image-20211231181817202](./assets/java/image-20211231181817202.png)

​		【按照作用范围】![image-20211231182152595](./assets/java/image-20211231182152595.png)

### 3. 自动类型转换

​		容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：![image-20211231182832924](./assets/java/image-20211231182832924.png)

- ​	有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。

- ​	byte,short,char 之间不会相互转换，他们三者在计算时首先转换为 int 类型。

- ​	boolean 类型不能与其它数据类型运算。
- ​    当把任何基本数据类型的值和字符串进行连接运算时，基本数据类型的值将自动转化为字符串类型。

### 4. 强制类型转换

​	将容量大的数据类型转换为容量小的数据类型 。 使用时要加上强制转换符，但可能造成精度降低或溢出，格外要注意！

​	字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。

​	boolean 类型不可以转换为其它的数据类型。

### 5. 编码

​	种类：ASCII 码（一字节）；Unicode 编码（4字节）；UTF 8（1-6字节）；

### 6. 进制，进制转换

- 二进制：0-1，满2进1。以 0b 或 0B
- 十进制：0-9 ，满10进1。
- 八进制：0-7 ，满8进1。以数字0开头表示。
- 十六进制：0-9 及 A-F ，满 16进1. 以 0x 或 0X 开头表示。此处的A-F不区分大小写。

### 7. 原码、反码、补码

​	略，太熟了这里。主要是为了用加法实现减法计算

## 二、运算符

### 1. 算术运算符

![image-20211231185827339](./assets/java/image-20211231185827339.png)

​	区分i++与++i；

​	+运算：除了数字运算还可以做字符串连接；

​	/运算：它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。

### 2. 赋值运算符

​	扩展赋值运算符： +=, -=, *=, /=,%=。

### 3. 比较运算符（关系运算符）

![image-20211231190233830](./assets/java/image-20211231190233830.png)

​	比较运算符的结果都是 boolean 型，也就是要么是 true ，要么是 false 。
​	比较运算符“不能误写成 “=”。

### 4. 逻辑运算符

![image-20211231190348823](./assets/java/image-20211231190348823.png)

"&"和"&&"的区别：
>	单&时，左边无论真假，右边都进行运算；
>	双&时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算 【**被短路了**】。

![image-20211231190548644](./assets/java/image-20211231190548644.png)

![image-20211231190605305](./assets/java/image-20211231190605305.png)



### 5. 位运算符

![image-20211231190619784](./assets/java/image-20211231190619784.png)

对于正数来说
>
>	空出来的最高位拿0补

对于负数来说
>
>右移以后，最高空出来的位拿 1 去补
>
>右移以后，高空出来的位拿 0 去补

![image-20211231190641014](./assets/java/image-20211231190641014.png)

### 6. 三元运算符

![image-20211231190914513](./assets/java/image-20211231190914513.png)

表达式 1 和表达式 2 为同种类型

三元运算符与 if else 的联系与区别：

>	三元运算符可简化 if else 语句
>	三元运算符要求必须返回一个结果。
>	if 后的代码块可有多个语句

### 7.运算符优先级总览

![image-20211231191059942](./assets/java/image-20211231191059942.png)

## 三、流程控制语句

### 1.顺序结构

​	程序从上到下逐行地执行，中间没有任何判断和跳转。

### 2.分支结构

​	根据条件，选择性地执行某段代码。

​	有 if…else 和 switch case 两种分支语句。

#### 2.1 if…else

![](./assets/java/image-20211231191420906.png)

![image-20211231191433026](./assets/java/image-20211231191433026.png)

if else 使用说明

>	条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量
>	语句块只有一条执行语句时，一对 可以省略，但建议保留
>	if-else语句结构，根据需要可以嵌套使用
>	当if-else 结构是“多选一”时，最后的 else 是可选的，根据需要可以省略
>	当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓
>	当多个条件是“包含”关系时，“小上大下/ 子上父下”

#### 2.2 switch case

```java
switch(表达式){
case 常量1:
	语句1;
	//break;
case 常量2:
	语句2;
	//break;
…
case 常量N:
	语句N
	//break;
default:
	语句;
	//break;
}
```

![image-20211231192427197](./assets/java/image-20211231192427197.png)

switch语句有关规则

>	switch( 表达式 中 表达式的值 必须 是下述几种类型之一： byte、short、char、int、枚举 (jdk 5.0)、String (jdk 7.0)；
>		case 子句中的值必须是常量 ，不能是变量名或不确定的表达式值；
>	同一 个 switch 语句，所有 case 子句 中 的常量值互不相同；
>		break 语句用来在执行完一个 case 分支后使程序跳出 switch 语句块；如果没有 break ，程序会顺序执行到 switch 结尾；
>	default 子句是 可任选 的 。同时，位置也是灵活的。当 没有匹配的 case 时，执行 default；

### 3.循环结构

​	根据循环条件，重复性的执行某段代码。有 while 、do…while 、for 三种循环语句。三种语句可以相互转换！

![image-20211231193123078](./assets/java/image-20211231193123078.png)

#### 3.1 for循环

```java
for(①初始化部分;②循环条件部分;④迭代部分){
	③循环体部分;
}
```
执行过程：①② ③ ④ ② ③ ④ ② ③ ④ ... ... ②

![image-20211231193512900](./assets/java/image-20211231193512900.png)

说明：

```
②循环条件部分为 boolean 类型表达式，当值为 false 时，退出循环
①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔
④可以有多个变量更新，用逗号分隔
```

#### 3.2 while循环

	①初始化部分;
	while(②循环条件部分){
		③循环体部分;
	    ④迭代部分;
	}
执行过程：①② ③ ④ ② ③ ④ ② ③ ④... ... ②

说明：

```
注意不要忘记声明④迭代部分。否则循环将不能结束变成死循环。
for循环和while循环可以相互转换。
```

#### 3.3 do-while循环

	①初始化部分
	do{
		③循环体部分;
		④迭代部分;
	}while(②循环条件部分)
执行过程：①③ ④ ② ③ ④ ② ③ ④... ... ②
说明：do-while循环至少执行一次循环体。

#### 3.4 嵌套循环

将一个循环放在另一个循环体内，就形成了嵌套循环。其中for ,while ,do…while 均可以作为外层循环或内层循环。

实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为 false时，才会完全跳出内层循环，才可结束外层的当次循环，开
始下一次的循环。

设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n 次。

#### 3.5 break

break 语句用于终止某个语句块的执行

```
{	……
	break;
	……
}
```

break 语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块

	label1:{
		label2:{
			label3:{
					break label2;
			}
		}
	}	

#### 3.6 continue

continue 只能使用在循环结构中。
continue 语句用于跳过其所在循环语句块的一次执行，继续下一次循环。
continue 语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环。

return 

```
并非专门用于结束循环的，它的功能是结束一个方法。当一个方法执行到一个 return 语句时，这个方法将被结束。
与 break 和 continue 不同的是， return 直接结束整个方法，不管这个 return 处于多少层循环之内。
```

break与continue

```
break 只能用于switch语句和循环语句中。continue只能用于循环语句中。二者功能类似，但continue是终止**本次**循环，break是终止**本层**循环。
break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。
标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。
很多语言都有 goto 语句， goto 语句可以随意将控制转移到程序中的任意一条语句上，然后执行它，但使程序容易出错。
Java中的break和continue 是不同于goto的。
```

# 0X02、数组

## 一、概念

定义：是多个**相同类型数据**按一定**顺序排列**的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。

常见概念：数组名、下标(或索引) 、元素、数组的长度

性质：

- 数组本身是引用数据类型，而数组中的**元素可以是任何数据类型**，包括基本数据类型和引用数据类型。
- 创建数组对象会在内存中开辟**一整块连续的空间**，而数组名中引用的是这块连续空间的首地址。
- 数组的长度一旦确定，就不能修改。我们可以直接通过下标(或索引)的方式调用指定位置的元素，**速度很快**。

分类： 按照维度：一维数组、二维数组、三维数组、…

​			按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组(即对 象数组)

## 二、一维数组的使用

### 1. 声明方式

​	type var[] 或 type[] var；

​	Java语言中声明数组时不能指定其长度(数组中元素的数)， 例如： int a[5]; //非法

​	**动态初始化**：数组声明且为数组元素分配空间与赋值的操作分开进行。

​				int[] arr = new int[3];

​	**静态初始化**：在定义数组的同时就为数组元素分配空间并赋值。

​				int arr[] = new int[]{ 3, 9, 8};

​				int[] arr = {3,9,8};

​	**默认初始化**：数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化。

| 数组元素类型 | 元素默认初始值 |
| ------------ | -------------- |
| byte         | 0 |
| short        | 0 |
| int          | 0 |
| long         | 0L |
| float        | 0.0F |
| double       | 0.0 |
| char         | \u0000 |
| boolean | false |
| 引用数据类型 | null |

### 2. 数组元素的使用

​	定义并用运算符new()为之分配空间后，才可以引用数组中的每个元素； 

​	数组元素的引用方式：数组名[数组元素下标] 

​		数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i]; 

​		数组元素下标从0开始；长度为n的数组合法下标取值范围: 0 —>n-1；如int a[]=new int[3]; 可引用的数组元素为a[0]、a[1]、a[2] 

​	每个数组都有一个属性length指明它的长度，例如：a.length 指明数组a的长度(元素个数)

​	**一般使用for循环对数组遍历，实现初始化或者读取**。

### 3. 一维数组的内存结构

```java
public class Test{
	public static void main(String args[]){
		int[] s;
		s = new() int[10];
		for(int i=0; i<10;i++){
			s[i] =2*i+1;
			System.out.println(s[i]);
		}
	}
}
```

​	![image-20220101110246906](./assets/java/image-20220101110246906.png)



内存简化结构：![image-20220101110501405](./assets/java/image-20220101110501405.png)



## 三、多维(二维)数组的使用

​	一维数组：序列。【存储的是某种数据】

​	二维数组：表格。【存储的是指向另一个数组的地址】从数组底层的运行机制来看，其实没有多维数组。

​	初始化：

​			有几个[] 就是几维数组，[]的位置任意，放在<数据类型> <变量名>之后就行 int

​			动态初始化：

​					int[][] arr = new int[3]~[2];   or int[][] arr = new int[3]~[];

​					int[][]arr = new int[]~[3]; //非法

​			静态初始化：

​					int[]~[] arr = new int[][]{{3,8,2},{2,7},{9,0,1,6}};

​	![image-20220101111158047](./assets/java/image-20220101111158047.png)

## 四、常用算法

1. 数组元素的赋值(杨辉三角、回形数等) 

2. 求数值型数组中元素的最大值、最小值、平均数、总和等 

3. 数组的复制、反转、查找(线性查找、二分法查找) 

4. 数组元素的排序算法

   分类：内部排序和外部排序。内部排序指整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。

   十大内部排序算法：选择排序（直接选择排序、堆排序），交换排序（冒泡排序、快速排序）， 插入排序（直接插入排序、折半插入排序、Shell排序），归并排序， 桶式排序，基数排序

## 五、算法的5大特征

| 输入（Input）                   | 有0个或多个输入数据，这些输入必须有清楚的描述和定义          |
| ------------------------------- | ------------------------------------------------------------ |
| 输入（Input）                   | 至少有1个或多个输出结果，不可以没有输出结果                  |
| 有穷性（有限性，Finiteness）    | 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤 可以在可接受的时间内完成 |
| 确定性（明确性，Definiteness）  | 算法中的每一步都有确定的含义，不会出现二义性                 |
| 可行性（有效性，Effectiveness） | 算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案   |

算法性能：空间复杂度，时间复杂度；稳定性，简单性；

【**练习：冒泡、快排**】

## 六、Arrys工具类的使用

java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。 

| boolean equals(int[] a,int[] b)   | 判断两个数组是否相等。                 |
| --------------------------------- | -------------------------------------- |
| String toString(int[] a)          | 输出数组信息。                         |
| void fill(int[] a,int val)        | 将指定值填充到数组之中。               |
| void sort(int[] a)                | 对数组进行排序。                       |
| int binarySearch(int[] a,int key) | 对排序后的数组进行二分法检索指定的值。 |

## 七、数组常见异常

数组脚标越界异常(ArrayIndexOutOfBoundsException)

```java
int[] arr = new int[2];
System.out.println(arr[2]); 
System.out.println(arr[-1]); 
//访问到了数组中的不存在的脚标时发生。
```

空指针异常(NullPointerException)

```java
int[] arr = null;
System.out.println(arr[0]);
//arr引用没有指向实体，却在操作实体中的元素时。
```

# 0X03、面向对象总述

## 一、思想阐述

​	面向对象与面向过程

​	编程的本质就是通过一次劳动，把重复性工作交给机器去做。人类的发展一直都是如此，不断提高生产力水平。生产力的水平一个是单位时间的效率（用卡车搬运煤炭要比手推车快），一个是重复性工作的替代（用机器代替人，解放双手）。

​	而重复性工作的特点就是有具体的解决步骤。通过把解决步骤用程序语言描述出来的过程，就是面向过程。面向对象与面向过程最大的不同是，面向对象是把所有的事物都抽象为一个类。而过程/行为只不过是这个类的一个属性/方法。这种逻辑思维背后涵盖着封装和复用的思想。面向对象是抽象出的一个对象，让对象去执行某个动作。把问题交给对象去做，只追求结果，不在意具体的实现，具体实现交给别的程序员。不可避免地，面向对象包含面向过程。

​	对象是什么，这要先谈到什么是类。类，就是一类、分类的意思。我们通过人为的规定，把具有某种共同特点的事物归为一类，这个过程就是抽象。这个过程在意的是事物的共同之处。比如狮子、老虎、人类，这三者都是动物。抽象就是去除与需求无关的特性，去除具体事物属性的属性值，归纳共同之处。而对象就是类的去抽象化（具体化），把类规定的每种属性都赋予特定的属性值、实现个性化，成为一个具体的例子。在编程语言中，对象就是按照类这个模板，在内存中开辟的一块区域，这个区域有自己特有的数据（属性值）。

## 二、概念辨析与实现

先记住以下几个词，不必搞懂：类、属性、方法；对象、实例化；封装、继承、多态。

### 1.类、属性、方法

一个类中可以有属性（也就是特性，存储数据）和方法（动作，处理数据）。

我们通过描述动物这个概念，来看一个类是如何创造出来的（我们就是创世主）。

一个动物有什么：四肢、头、身体、性别、年龄、名字。

一个动物可以干什么：移动、吃东西、发出叫声

好的，我们把以上概括通过Java语言来描述一边即可，这就是Java的类！

```java
class animal{
	int leg = 4;
	String environment = 'sea'; //land,sky
    String name = 'mankind';
    String gender = ''
    int age = 0;
    public void move(){
        System.out.println('walk');
        //System.out.println('fly');
    } 
    public void sounds(){
        System.out.println('汪汪汪');
       //System.out.println('喵喵喵');
    }
}
//该类定义了一个动物的某些属性，比如肢体数量，生存环境，物种名称，年龄。还有如何运动，叫声
```

这些属性当然不能完整描绘一个动物，也没必要，我们根据需求来就行。

### 2. 对象、实例化

​	将类变成对象的过程就是实例化（构造方法来完成具体过程）。类是模板，对象就是按照模板造出来的具体事物。比如人类，这是某个层次的抽象概念，那么"张三"所指的这个人就是人类这个物种的具体例子。我符合人类规定的所有条件，但也有自己的特点，例如样貌、体型等等。

​	现在，我们大脑中已经有了一个想象的动物，我们如同女娲造人一样，拿泥把这个动物捏出来。这个动物几条腿，3条。这个动物是公是母，公。这个动物会走路还是会游泳还是会飞。这个过程就是实例化，把抽象的类、这个模板、一个脑子里的概念，变成具体的，现实存在的一个事物。我们用Java语言来描述一下。

```Java
class animalTest{
	public static void main(String args[]){
		animal dog = new animal();
		dog.leg = 3;
		dog.gender = 'male';
		dog.move();
		dog.sounds();
	}
}
```

### 3.封装、继承、多态

【封装】：之前我们一直在做，就是把一段代码用{}包裹起来，然后起个名字就可以调用了，这样我们就减少了重复。当然，这仅仅是方法的封装，而且方法的封装还有很多细节，比如传入参数和返回类型。

【继承】：我现在想造一个人（开车2333），已经有了动物这个类，动物有的特性人都有，我也就懒得重复某些东西了，直接拿过来就好，这就是继承。我们用Java语言描述一下。

```java
class mankind extends animal{
	public void sounds(String words){
        System.out.println(words);
    }
}
class mankindTest{
	public static void main(String args[]){
		mankind people1 = new mankind();
		people1.leg = 2;
		people1.gender = 'female';
		people1.sounds("你好");
	}
}
```

你看，虽然mankind里什么属性都没有定义，但还是可以调用那些属性。

当然你也可以定义人类特有的属性和方法。这里我把sounds方法进行了重载，稍后再说。

被继承的类叫做父类，另一个类则叫作子类。子类拥有父类所拥有的一切。那么父类想要有子类的特性呢？这就要说到【多态】了。直接上代码。

```java
class 多态Test{//这里命名不规范，但是语法对
	public static void main(String args[]){
		mankind animal = new mankind();
	}
}
```

你看，按照子类的模板创建了一块内存区域，但是把这个区域引用给了animal这种类别。关于多态就讲这么多，至于子类特有父类可不可以访问等这些问题以后讲。

# 0X04、面向对象

”万事万物皆对象“

## 一、"类"和"对象"的概述

类 (Class) 和 对象 (Object) 是面向对象的核心概念。

- 类是对 一类事物的描述 ，是抽象的、概念上的定义。
- 对象是实际存在的该类事物的每个个体，因而也称为实例。

类的组成：属性/成员变量、方法/函数、代码块、内部类

类的格式：

```java
修饰符 class 类名{
	属性声明
	方法声明
}
//说明：修饰符 public ：类可以被任意访问
//类的正文要用{}括起来
```

类的构建步骤：

1. 定义类（考虑修饰符、类名）
2. 编写类的属性（考虑修饰符、属性 类型、属性名 、 初始化值）
3. 编写类的方法（考虑修饰符、返回 值类型、方法名、形参等）

类的实例化：

​	创建对象语法： <类名> <对象名> = new <类名>;

​	使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）

类的访问机制：

​	在一个类中的访问机制： 类中的方法可以直接访问类中的成员变量 （例外：static方法访问非static编译不通过 。）

​	在不同类中的访问机制： 先创建要访问类的对象 再用对象访问类中定义的成员 。

对象的产生、使用、生命周期、内存解析：

![image-20220101174303688](./assets/java/image-20220101174303688.png)

【匿名对象】

​	可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。如：new Person().shout();

​	使用场景：如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。

​	使用习惯：我们经常将匿名对象作为实参传递给一个方法调用。

## 二、类的成员

### 1. 属性

① 语法格式：修饰符 数据类型 属性名 = 初始化值;

```
说明1: 修饰符
	常用的权限修饰符有： private 、缺省、 protected 、 public
	其他修饰符： static 、 final ( 暂不考虑
说明2 ：数据类型
	任何基本数据类型 如 int 、 Boolean) 或 任何引用数据类型。
说明 3 ：属性名
	属于标识符，符合命名规则和规范即可。
```

② 类内的变量：

 1. 辨别：在方法体外的为成员变量，即属性。在方法体内的变量为局部变量。

    ![image-20220102075047238](./assets/java/image-20220102075047238.png)

 2. 区别：变量在内存中的位置与生命周期不同

|              | 成员变量                            | 局部变量                                 |
| ------------ | ----------------------------------- | ---------------------------------------- |
| 声明位置     | 直接声明在类中                      | 方法形参或内部、代码块内、构造器内等     |
| 修饰符       | private、public 、static 、final 等 | 不能用权限修饰符修饰，可以用final        |
| 初始化值     | 有默认初始化值                      | 没有默认初始化值，必须显式赋值，方可使用 |
| 内存加载位置 | 堆空间 或 静态域内                  | 栈空间                                   |

3. 内存图解![image-20220102075533338](./assets/java/image-20220102075533338.png)

### 2. 方法

①什么是方法(method 、函数)

​	方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。

​	将功能封装为方法的目的是，可以实现代码重用，简化代码

​	Java 里的方法不能独立存在，所有的方法必须定义在类里。

②语法格式

```Java
修饰符 返回值类型 方法名 (参数类型 形参1,参数类型 形参2, ...){
	方法体程序代码
	return 返回值;
｝
```

③分类

|        | 无返回值          | 有返回值                           |
| ------ | ----------------- | ---------------------------------- |
| 无形参 | void 方法名( ){ } | 返回值的类型 方法名（ ) { }        |
| 有形参 | void 方法名( ){ } | 返回值的类型 方法名（形参列表) { } |

④方法调用

![image-20220102081408502](./assets/java/image-20220102081408502.png)

⑤注意事项

​	方法被调用一次，就会执行一次

​	没有具体返回值的情况，返回值类型用关键字void表示 ，那么方法体中可以不必使用 return 语句。如果使用，仅用来结束方法。

​	定义方法时，方法的结果应该返回给调用者，交由调用者 处理 。

​	方法中只能 调用 方法或属性， 不可以在方法内部定义方法。

⑥方法的重载

​	重载的概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。

​	特点：与返回值类型无关，只看参数列表，且参数列表必须不同（参数个数或参数类型 ）。调用时，根据方法参数列表的不同来区别。

⑦形参与实参，可变个数的形参

​	1. 形参 ：方法声明时的参数

​	2. 实参： 方法调用时 实际传给形参的参数值

​	3. 可变个数形参的声明格式：方法名(参数的类型名 ... 参数名)

- 指定类型的参数个数是可变多个： 0 个， 1 个或多个
- 可变个数形参的方法与同名的方法之间，彼此构成重载
- 可变参数的使用与数组是一致的
- 方法的参数部分有可变形参，**需要放在形参声明的最后，故最多只能声明一个可变个数形参**

​	4.传参机制

​		形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参。（**意味着在方法内不会修改外部**）

​		形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参

⑧递归

​	递归方法：一个方法体内调用它自身。

​	方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。

​	递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。

### 3. 构造器

​	①构造器的作用：创建对象，给对象进行初始化

​	②构造器的特征：

- 它具有与类相同的名称
- 它不声明返回值类型（与声明为void不同）。
- 不能被 static 、final 、synchronized 、abstract 、native 修饰
- 不能有return语句返回值

​	③语法格式：

```java
修饰符 类名(参数列表 ) {
	初始化语句;
}	
```

④分类：根据参数不同，构造器可以分为如下两类。

- 隐式无参构造器（系统默认提供）
- 显式定义一个或多个构造器（无参、有参）

⑤注意

- Java 语言中，每个类都至少有一个构造器
- 默认构造器的修饰符与所属类的修饰符一致
- **一旦显式定义了构造器， 则系统不再提供默认构造器**
- 一个类可以创建多个重载的构造器
- 父类的构造器不可被子类继承

### 4. 代码块

​	作用：对Java类或对象进行初始化

​	分类：只能被static修饰，称为静态代码块 (static block)，没有使用static修饰的，为非静态代码块。

```
静态代码块：用static修饰的代码块
	1.对静态属性初始化。即：不可以调用非静态的属性和方法。
	2.若有多个静态的代码块，那么按照从上到下的顺序依次执行。
	3.静态代码块的执行要先于非静态代码块。
	4.静态代码块随着类的加载而加载，且只执行一次。
非静态代码块：没有static修饰的代码块
	1.可以对类的属性、类的声明进行初始化操作。
	2.除了调用非静态的结构外，还可以调用静态的变量或方法。
	3.若有多个非静态的代码块，那么按照从上到下的顺序依次执行。
	4.每次创建对象的时候，都会执行一次。且先于构造器执行。
```

![image-20220122215430809](./assets/java/image-20220122215430809.png)

### 5. 内部类

概念：在 Java中，允许一个类的定义位于另一个类的内部，前者称为内部类 ，后者称为外部类 。

意义：当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。

分类：成员内部类（static和非static）；局部内部类（不谈修饰符。如同局部变量，定义在方法、代码块内）；匿名内部类

成员内部类：

​		作为一个类：①可以定义属性、方法、构造器。②可以用final、abstract修饰。

​		作为外部类的一个成员：可以被"权限修饰符"、static修饰

如何实例化成员内部类对象

```java
public class InterClassTest {
	public static void main(String[] args) {
		Person p = new Person();
        //实例化非静态内部类
		Person.Hung  h = p.new Hung();
        //实例化静态内部类
		Person.eye eyeLeft = new Person.eye();
	}
}
class Person{
    //非静态成员内部类
	class Hung{
		public void breath() {
			System.out.println("肺在呼吸");
		}
	}
    //静态成员内部类
	static class eye{
	}
}
```

成员内部类调用外部类属性

​	变量名没有重名可以直接使用；变量名重名：外部类.this.变量名。

```java
class Person{
    String name = "filwsx";
	class Hung{
		String name = "hung";
		public void breath() {
			System.out.println("肺在呼吸");
            System.out.println(Person.this.name);
            System.out.println(name);
            System.out.println(this.name);
            System.out.println(new Person.eye().name);
		}
	}
	static class eye{
		String name = "eye";
	}
}
```

局部内部类的使用

```java
//开发中很少见
public void method(){
	//局部内部类
	class AA{
	}
}
public Comparable getComparable(){
	return new Comparable(){
		@Override
		public int compareTo(Object o) {
			return 0;
		}
	};
}
```

Innerclass 一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。

## 三、类的特征

### 1. 封装性

①blackBox思想：

- 人的精力有限，需要提高效率。其中一个方式就是把复杂的实现打包成工具，会用即可，不用关注内部的实现原理。比如人可以用电脑连接打印机，打印出一篇文章，但是不需要在意电脑怎们工作的，连接采用的协议，打印机如何控制墨滴喷溅在纸张上。
- 封装性正是实现黑箱思想的一种特性。其必然包含隐藏，内部属性和方法的隐藏。把该隐藏的隐藏起来，该暴露的暴露出来 。 这就是封装性的设计思想。
- 程序设计追求 “高内聚，低耦合”：
  - 高内聚 ：类的内部数据 操作细节自己完成，不允许外部干涉；
  - 低耦合 仅对外暴露 少量的 方法 用于使用 。
- 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。

②使用者对类内部定义的属性(对象的成员变量)的直接操作会导致数据的错误、混乱或**安全性**问题。

​	Java中通过将数据声明为私有的，再提供public方法 getXxx 和 setXxx 实现对该属性的操作以实现下述目的：

- 隐藏 一个类中 不需要对外提供的 实现细节；
- 使用者只能通过事先定制好的 方法来访问数据 可以方便地加入控制逻辑限制对属性的不合理操作；
- 便于修改，增强代码的可维护性；

③四种访问权限修饰符

​	public、protected、(缺省)、private置于类的成员定义前，用来限定对象对该类成员的访问权限。

| 修饰符    | 类内部 | 同一个包不同 | 不同包的子类 | 同一个工程 |
| --------- | ------ | ------------ | ------------ | ---------- |
| private   | Yes    |              |              |            |
| (缺省)    | Yes    | Yes          |              |            |
| protected | Yes    | Yes          | Yes          |            |
| public    | Yes    | Yes          | Yes          | Yes        |

对于class 的权限修饰只可以用 public 和 default(缺省)。

- public 类可以在任意地方被访问。
- default 类只可以被同一个包内部的类访问。

### 2. 继承性

多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。此处的多个类称为子类( 派生类)，单独的这个类称为父类( 基类 或 超类) 。

类继承语法规则：

```Java
class Subclass extends SuperClass{}
```

作用：

- 继承的出现减少了代码冗余，提高 了代码的复用性。
- 继承的出现，更有利于功能的扩展。
- 继承的出现让类与类之间产生了关系 ，提供了多态的前提 。

注意：

- 不要仅为了获取其他类中某个功能而去继承
- 子类继承了父类，就继承了父类的方法和属性。
  - 子类不能直接访问父类中私有的成员变量和方法。
  - 可以使用父类中定义的方法和属性，也可以创建新的数据和方法。
- 在 Java 中，继承的关键字用的是“ extends ”，即子类不是父类的子集而是对父类的“扩展”。
- Java 只支持单继承和多层继承，不允许多重继承
  - 一个子类只能有一个父类
  - 一个父类可以派生出多个子类

**方法的重写：**

定义：在子类中可以根据需要对从父类中继承来的方法进行改造 也称为方法的重置、覆盖 。在程序执行时，子类的方法将覆盖父类的方法。

要求：

- 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表
- 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型
- 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限
- 子类不能重写父类中声明为private权限的方法
- 子类方法抛出的异常不能大于父类被重写方法的异常

注意：子类与父类中同名同参数的方法必须同时声明为非 static 的( 即为重写)，或者同时声明为static的( 不是重写，因为 static 方法是属于类的，子类无法覆盖父类的方法)。

子类对象的实例化过程![image-20220102105841878](./assets/java/image-20220102105841878.png)



### 3. 多态性

①对象的多态性：父类的引用指向子类的对象

②Java 引用变量有两个类型：编译时类型和运行时类型 。 

- 编译时类型由声明该变量时使用的类型决定
- 运行时类型由实际赋给该变量的对象 决定 。
- 简称： 编译时看左边；运行时看右边 。
- **若编译时类型和运行时类型不一致，就出现了对象的多态性 (polymorphism)**
- 多态情况下，
  - "看左边"看的是父类的引用(父类中不具备子类特有的方法)
  - “看右边" 看的是子类的对象(实际运行的是子类重写父类的方法)

③应用：抽象类和接口。

④对象的多态

- 在 Java中子类的对象可以替代父类的对象使用
  - 一个变量只能有一种确定的数据类型
  - 一个引用类型变量可能指向 引用 多种不同类型的对象
- 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型( upcasting)。
- 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法。
- 方法形参声明的类型为父类，可使用子类对象作为实参传入

⑤虚拟方法调用：

​	条件：使用多态声明父类对象。父类与子类定义了同名同参数的方法，且该方法被调用。

​	将此时父类的方法称为**虚拟方法**，因为父类是根据赋给的不同子类对象，动态调用子类的该方法。这样的方法调用在编译期是无法确定的。

⑥区分方法的重载与重写

- 对于重载而言，在方法调用之前，**编译器就已经确定了所要调用的方法**，这称为 “早绑定”或“静态绑定
- 对于多态，只有**等到方法调用的那一刻**，JVM才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定"。

⑦instanceof操作符

x instanceof A ：检验 x 是否为类 A 的对象，返回值为 boolean 型。

- 要求 x 所属的类与类 A 必须是子类和父类的关系，否则编译错误。
- 如果 x 属于类 A 的子类 B ，x instanceof A 值也为 true 。

⑧对象类型转换

- 基本数据类型的 Casting

  - 自动类型转换 ：小的数据类型可以自动转换成大的数据类型
  - 强制类型转换： 可以把大的数据类型强制转换 ( 成小的数据类型

- 对 Java 对象的强制类型转换称为造型

  - 从子类到父类的类型转换可以自动进行

  - 从父类到子类的类型转换必须通过造型 强制类型转换 实现

  - 无继承关系的引用类型间的转换是非法的

  - 在造型前可以使用 instanceof 操作符测试一个对象的类型

    ![image-20220102132016836](./assets/java/image-20220102132016836.png)

⑨子类继承父类

- 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。
- 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。

​	这两句话把我给干蒙了。没看懂！！！重写是动态行为，子类可以通过super关键字调用，但是子类对象不能？20220102 1346

​	以上三句话把我干蒙了！尤其是第三句我写了个啥！20220121 1110 主要是实例变量搞不懂，完全相同了用哪个还是都能用？

## 四、关键字

### 1. this

this的作用与其字面意思一样，表示当前、这个。

- 它在方法内部使用，即这个方法所属对象的引用；
- 它在构造器内部使用，表示该构造器正在初始化的对象。
- this 可以调用类的属性、方法和构造器

this与构造器

- 在类的构造器中使用 " this(形参列表) "的方式，调用本类中重载的其他的构造器！
-  " this(形参列表) "必须声明在类的构造器的首行！
  - 那么这意味着，在类的一个构造器中，最多只能声明一个" this(形参列表) "
- 构造器中不能通过 " this(形参列表) "的方式调用自身构造器。
  - 那么这意味着，一个类中声明了 n 个构造器，则最多有n-1个构造器中使用了 " this(形参列表) "

### 2. package 与 import

​	编写的class实际存储在磁盘某个路径中。例如某个class存储在src\com\filwsx\javabasics，那么在Java中表达为com.filwsx.javabasics。package用来指定class归属于哪个包。

​	包的作用：

- 包帮助管理大型软件系统将功能相近的类划分到同一个包中 。 比如 MVC 的设计模式
- 包可以包含类和子包划分项目层次便于管理
- 解决类命名冲突的问题
- 控制访问权限

​		java中不可避免地要使用别人写的类，我们在使用时需要告诉编译器你用的class存放在哪里。这就是import关键字，用来引入一个类或者包。

- import声明在包的声明和类的声明之间。
- 如果需要导入多个类或接口，那么就并列显式多个 import 语句即可
- 可以使用 java.util.* 的方式，一次性导入util 包下所有的类或接口。
- 如果导入的类或接口是java.lang 包下的，或者是当前包下的，则可以省略此 import 语句。
- 如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类。
- 如果已经导入 java.a 包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。
- import static 组合的使用：调用指定类或接口下的静态的属性或方法。

### 3. super

因为重写的存在，但有时也需要调用父类定义的方法等成员，这时候就要用到super关键字。

- super 可用于访问父类中定义的属性
- super 可用于调用父类中定义的成员方法
- super 可用于在子类构造器中调用父类的构造器
  - **子类中所有的构造器默认都会访问父类中空参数的构造器**
  - 当父类中没有空参数的构造器时，子类的构造器必须通过"this(参数列表)"或者"super( 参数列表)"语句指定调用本类或者父类中相应的构造器 。 同时只能 二选一，且必须放在构造器的首行。
  - **如果子类构造器中既未显式调用父类或本类的构造器且父类中又有无参的构造器，则编译出错。**

注意：

- 尤其当子父类出现同名成员时可以用 super表明调用的是父类中的成员
- super 的追溯不仅限于直接父类
- super 和 this 的用法相像 this 代表本类对象的引用 super 代表父类的内存空间的标识

this和super的区别

| 区别点     | this                                                   | super                                    |
| ---------- | ------------------------------------------------------ | ---------------------------------------- |
| 访问属性   | 访问本类中的属性，如果本类没有此属性则从父类中继续查找 | 直接访问父类中的属性                     |
| 调用方法   | 访问本类中的方法，如果本类没有此方法则从父类中继续查找 | 直接访问父类中的方法                     |
| 调用构造器 | 调用本类构造器，必须放在构造器的首行                   | 调用父类构造器，必须放在子类构造器的首行 |

### 4. static

static可修饰的成员

​	①static修饰类的属性，可以让类的所有实例共享这一属性（一个实例修改，处处可见）。

​	②static修饰类的方法，可以不需要实例化即可调用类的方法。

​		那也意味着不能访问非静态成员、this、super，因为没有实例化这一过程，这些属性内存中不存在

​		也意味着方法不能被重写。

​	③static修饰类的代码块：略。

​	④static修饰类的内部类：略。

被修饰后的成员具备以下特点：

​	随着类的加载而加载；优先于对象存在；修饰的成员，被所有对象所共享；

​	访问权限允许时，可不创建对象，直接被类调用。

理解main方法：

​	Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public。

​	因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的。

​	该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。

### 5. final

在Java中声明类、变量和方法时，可使用关键字final来修饰,表示“最终的”。
	final标记的类不能被继承。提高安全性，提高程序的可读性。
		比如：String类、System类、StringBuffer类
	final标记的方法不能被子类重写。
		比如：Object类中的getClass()。
	final标记的变量(成员变量或局部变量)即称为常量。名称大写，且只能被赋值一次。
	final标记的成员变量必须在声明时或在每个构造器中或代码块中显式赋值，然后才能使用。
		比如：final double MY_PI = 3.14;

![image-20220122222842415](./assets/java/image-20220122222842415.png)

o.i++可以操作，i又不是final。但是o因为是final，它不能变了（这个对象变量指向的地址不可变）

### 6.abstract（抽象类）

①用abstract来修饰一个方法，该方法叫做**抽象方法**。

​	抽象方法：只有方法的声明，没有方法的实现，以分号结束。

②用abstract关键字来修饰一个类，这个类叫做**抽象类**。

​	有一个或更多抽象方法的类称为抽象类。

​	抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。

​	含有抽象方法的类必须被声明为抽象类。

​	抽象类不能被实例化，而是用来被继承的。

​	抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。

③不能用abstract修饰变量、代码块、构造器；

④不能用abstract修饰私有方法、静态方法、final的方法、final的类。

⑤**抽象类的匿名子类**

​	在()后实现抽象类的抽象方法，不显式定义子类

```java
Person p = new Person(){
	@Override
	public void walk(){
	}
};
```
## 五、object类和包装类

### 1.object类

①Object 类是所有 Java 类的根父类。

如果在类的声明中未使用 extends 关键字指明其父类则默认父类为java.lang.Object类。

②Object类中的主要结构

| 方法名                            | 类型 | 描述           |
| --------------------------------- | ---- | -------------- |
| public Object()                   | 构造 | 构造器         |
| public boolean equals(Object obj) | 普通 | 对象比较       |
| public int hashCode()             | 普通 | 取得Hash码     |
| public String toString()          | 普通 | 对象打印时调用 |

③对比 == 与 equals() 

​	**基本类型比较用==，除此之外均用equals()，这里在String中常出错。**

​	**子类比较过程中，父类属性的比较问题？？？**

- ==
  - 基本类型比较值：只要两个变量的值相等即为 true。
  - 引用类型比较引用：只有指向同一个对象时才返回 true 。
  - 用进行比较时符号两边的数据类型必须兼容( 可自动转换的基本数据类型除外)，否则编译出错
  
- equals() 
  - 所有类都继承了 Object，也就获得了 equals() 方法 。 还可以重写
  - 只能比较引用类型，其作用与==相同，比较是否指向同一个对象
  - 当自定义使用 equals() 时可以重写 。 用于比较两个对象的内容是否都相等
  
- 重写equals() 方法的原则
  - 对称性：如果x.equals(y) 返回是 true ，那么 y,equals(x) 也应该返回是true 。
  - 自反性： x.equals(x) 必须返回是 true 。
  - 传递性 ：如果 x.equals(y) 返回是 true 而且 y.equals(z) 返回是 true，那么 z.equals(x) 也应该返回是 true。
  - 一致性： 如果 x.equals(y) 返回是 true ，只要x和y内容一直不变，不管你重复 x.equals(y) 多少次返回都是 true 。
  - 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。
  
  ![image-20220121183557400](./assets/java/image-20220121183557400.png)

④ toString() 方法

- toString 方法在 Object 类中定义，其返回值是 String 类型，返回类名和它的引用地址 。
- 在进行String与其它类型数据的连接操作时，自动调用 toString 方法
- 可以根据需要在用户自定义类型中重写 toString 方法
- 基本类型数据转换为 String 类型时，调用了对应包装类的toString方法

### 2.包装类

① 针对八种基本数据类型定义，相应的引用类型包装类（封装类）

​	有了类的特点，就可以调用类中的方法。

![image-20220102220028938](./assets/java/image-20220102220028938.png)

②包装类的使用

- 基本数据类型包装成包装类的实例【装箱】
  - 通过包装类的构造器实现：int i = 500; Integer t = new Integer(i);
  - 还可以通过字符串参数构造包装类对象：Float f = new Float(“4.56”);
- 获得包装类对象中包装的基本类型变量【拆箱】
  - 调用包装类的 xxxValue 方法：boolean b = bObj.booleanValue();
- 字符串转换成基本数据类型
  - 通过包装类的构造器实现：int i = new Integer("12");
  - 通过包装类的 parseXxx (String) 静态方法：Float f = Float.parseFloat( "12.1");
- 基本数据类型转换成字符串
  - 调用字符串重载的 valueOf 方法：String fstr = String.valueOf (2.34F);
  - 更直接的方式：String intStr = 5 + ""

![image-20220114213244946](./assets/java/image-20220114213244946.png)

## 六、接口

意义

​	解决类的单继承带来的问题。接口和类是并列概念。

思想

​	接口就是规范，定义的是一组规则，体现了现实世界中“如果你要则能 ......”的思想。 继承“是不是”的关系，而接口实现则是“能不能
”的关系。

​	接口的本质是契约，标准，规范 ，就像我们的法律一样。制定好后大家都要遵守。

接口(interface)是抽象方法和常量值定义的集合。
	用interface来定义。
	接口中的所有成员变量都默认是由 public static final 修饰的。【JDK7及以前】
	接口中的所有抽象方法都默认是由 public abstract 修饰的。【JDK7及以前】
	接口中除了全局常量和抽象方法外，还可定义静态方法、默认方法(略)。【JDK8开始】
	接口中没有构造器。

定义 Java 类的语法格式：先写extends ，后写implements。
一个类可以实现多个接口，接口也可以继承其它接口 。
实现接口的类中必须提供接口中所有方法的具体实现内容。否则，仍为抽象类。
接口的主要用途就是被类实现（面向接口编程）。
与继承关系类似，接口与实现类之间存在多态性

抽象类与接口有哪些异同：
​	同：不可实例化，可被继承。
​	异：构造器有无，多继承。

接口匿名实现类：类似抽象类的匿名子类。

### 接口和抽象类之间的对比

![image-20220126212335839](./assets/java/image-20220126212335839.png)

### 面试题

![image-20220126215229153](./assets/java/image-20220126215229153.png)

### Java8的接口新特性

接口中定义的静态方法，只能通过接口名来调用。

默认方法：①通过实现类的对象调用（实现类也可"重写"）。②实现类内部调用：接口名.super.默认方法③示例

```java
public default String method1() {
	return "上海";
}
```

在子类中，继承的父类、实现的接口有重名方法，且没有重写过，那么默认调用的是父类里的方法（类优选原则）。

接口冲突：类实现多个接口，多个接口之间出现了同名同参的方法，此时必须重写这个方法。

# 0X05、异常处理

## 异常概述与异常体系结构

【**不存在完美的代码**！代码的正常运行是建立在某种前提之下。但是系统是时刻变化的，总有预料不到的情况发生】

概念：在 Java语言中将**程序执行中**发生的不正常情况称为异常 （开发过程中的语法错误和逻辑错误不是异常）。

分类：①Error：Java 虚拟机无法解决的严重问题 。例如StackOverflowError 和 OOM。

​			②Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如数组越界、无网络

​			其他分类：语法错误、设计/逻辑错误；编译错误、运行错误；

​			程序只能处理 Exception，而对Error无能为力 。

错误演示

```java
public static void main(String args[]) {
	//StackOverflowError
	main(args);
	//OOM:OutOfMemoryError
	Integer arr[] = new Integer[1024*1024*1024];
}
```

错误的处理：终止程序（这是大多数情况不希望的），解决错误（代码构建时预料到，运行时才能发现）。

<img src="assets/image-20220128152105439.png" width="400px"/>

​		红色为编译时异常（checked），蓝色为运行时异常（unchecked）。

## 常见异常

```java
 /**
 * java.lang.Throwable
 * 		|-----java.lang.Error:一般不编写针对性的代码进行处理。
 * 		|-----java.lang.Exception:可以进行异常的处理
 * 			|------编译时异常(checked)
 * 					|-----IOException
 * 						|-----FileNotFoundException
 * 					|-----ClassNotFoundException
 * 			|------运行时异常(unchecked,RuntimeException)
 * 					|-----NullPointerException
 * 					|-----ArrayIndexOutOfBoundsException
 * 					|-----ClassCastException
 * 					|-----NumberFormatException
 * 					|-----InputMismatchException
 * 					|-----ArithmeticException
 */
```

编译时异常

```java
@Test
	public void FileNotFoundExceptionTest() {
		File file = new File("hello.txt");
		FileInputStream fis = new FileInputStream(file);
		int data = fis.read();
		while(data != -1){
			System.out.print((char)data);
			data = fis.read();
		}
		fis.close();		
	}
```

## 异常处理

Java采用的异常处理机制 ，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。

Java提供的是异常处理的“抓抛模型”。Java程序的执行过程中如出现异常，会生成一个“异常类对象”，该异常对象将被提交给 Java运行时系统这个过程称为抛出（throw）异常。（异常出现后的代码不再执行）

### 机制一：try catch finally

#### ①语句格式

```java
//try用来捕获异常。
//catch语句块对异常对象进行处理
try{
	//可能出现异常的代码
}catch(异常类型1 变量名1){
 	//处理异常的方式1
}catch(异常类型2 变量名2){
	//处理异常的方式2
}catch(异常类型3 变量名3){
	//处理异常的方式3
}//... ...很多个catch
finally{
 	//一定会执行的代码
}
```

finally是可选的；try-catch-finally结构可以嵌套。

**使用try将可能出现异常代码包装起来**，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配

一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没有写finally的情况）。继续执行其后的代码。

catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。

catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错

常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()

在try结构中声明的变量，再出了try结构以后，就不能再被调用。

体会1：使用try-catch-finally处理编译时异常，使得程序在编译时不再报错，但是运行时仍可能报错。相当于将一个可能出现的异常延迟到运行时出现。

体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了【一般发现了都是改代码不让异常再次出现】。针对于编译时异常，我们一定要考虑异常的处理。

#### ②finally的使用

用不用finally，貌似catch处理后的代码都会运行。

但是万一try-catch里有异常怎么办？或者try-catch内有return语句。finally都会执行，且是最后执行的（finally内的return有效）。

用途：关闭jvm无法回收的一些物理资源，比如数据库连接、输入输出流、socket连接。

快捷操作：eclipse里，选择可能存在异常的代码，右键surround with，try-catch block。

### 补：JUnit的测试工具

方法前一行加入@Test，之后导包。选择要测试的方法右键，使用JUnit运行。

### 机制二：throws

向上抛！（简称甩锅）

如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理 。如果异常没有在调用者方法中处理，它继续被抛给这个调用
方法的上层方法 。这个过程将一直继续下去直到异常被处理 。

如果 一个异常回到 main() 方法，并且main() 也不处理则程序运行终止 。

#### 语句格式

```java
public static void main(String args[]){
	try {
		method2();
	} catch (IOException e) {	
		e.printStackTrace();
	}
}
public void method2() throws IOException{
		method1();
}
public void method1() throws FileNotFoundException,IOException{
}
```

"throws + 异常类型"写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。
	一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。
​	异常代码后续的代码，就不再执行！

try-catch-finally:真正的将异常给处理掉了。throws的方式只是将异常抛给了方法的调用者。并没有真正将异常处理掉。  

#### 重新方法的异常抛出

​	子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型

### 开发中如何选择使用

try-catch-finally? 还是 throws?

如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。

如果方法a中调用了另外的几个方法，而且这几个方法是递进执行的。建议这几个方法使用throws的方式进行异常处理。而方法a考虑使用try-catch-finally方式进行处理。

## 手动抛出异常：throw

异常对象的产生：①系统自动生成（api开发者手动抛出的）。②手动生成一个异常对象，并抛出。

```java
throw new Exception("");	//抛出一个Exception类型的异常，""内为异常信息。
```

## 用户自定义异常类

①自己定义一个类，并继承自某个现有的异常类。

②提供一个 static final long 的 serialVersionUID。【异常的唯一标识】

③提供重载构造器：空参、String msg。

## 总结

![image-20220128204906715](./assets/java/image-20220128204906715.png)

# 0X06易错

1.基本语法-变量

```java
System.out.println(3+4+“Hello!”); //输出 7Hello!
System.out.println(“Hello!”+3+4); //输出： Hello!34
System.out.println(‘a’+1+“Hello!”); //输出 98Hello!
System.out.println(“Hello”+‘a’+1); //输出： Helloa1
```

2.概念区分

以下分类观点错误：编译型与解释型，面向对象与面向过程。这种分类不合理。

编译型与解释型：不论哪一种语言，都需要变成二进制代码计算机才理解，编译和解释只能区分代码的运行模式，并不是不同语言的本质区别。python被称为解释型语言，而Java在9版本中出现了jShell也可以实现解释运行。

面向对象与面向过程：面向对象语言java也可以写出面向过程风格的代码，面向过程语言c也可以通过结构体和指针写出面向对象风格的代码，所以面向对象和过程是两种代码设计思想而不是语言区分。面向对象的本质是message的传递和处理，这个参考[这里](https://wiki.c2.com/?AlanKaysDefinitionOfObjectOriented)。
