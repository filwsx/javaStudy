# *0X01、多线程

## 基本概念

程序：为完成特定任务、用某种语言编写的一组指令的集合，即指一段静态的代码。

进程：是程序的一次执行过程，是一个动态的过程。有它自身的产生、存在和消亡的过程。

线程：进程可进一步细化为线程，是一个程序内部的一条执行路径。【一个进程可以有一个或多个线程】

​			若一个进程同一时间**并行**执行多个线程，就是支持多线程的。

​			线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器 ( pc)，线程切换的开销小。

​			一个进程中的多个线程共享相同的内存单元、内存地址空间。这就使得线程间通信更简便、高效。

​			多个线程操作共享的系统资源可能就会带来**安全的隐患** 。

CPU的单核和多核

​		在一个时间单元内，一个单核CPU只能执行一个线程的任务。那么单核上的多线程其实是一种假的多线程。因为cpu频率高，线程间来回切换速度很快，人的感觉是同时多个线程运行。【切换会消耗cpu资源】

​		一个java.exe至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。

​		并行：多个CPU核同时执行多个任务。比如：多个人同时做不同的事 。

​		并发：一个CPU核( 采用时间片)"同时""执行多个任务。比如：秒杀、多个人做同一件事。

多线程的优点

​	1.提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
​	2.提高计算机系统CPU的利用率。
​	3.改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。

何时需要多线程

​	程序需要同时执行两个或多个任务。
​	程序需要实现一些需要等待的任务时，如用户输入、文件读写。
​	操作、网络操作、搜索等。需要一些后台运行的程序时。

## 线程的创建与使用

### Thread 类

特性

```
每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体。
通过该Thread对象的start()方法来启动这个线程，而非直接调用run()。
```

构造器

```
Thread创建新的Thread对象。
Thread(String threadname):创建线程并指定线程实例名。
Thread(Runnable target):指定创建线程的目标对象，它实现了Runnable接口中的run方法。
Thread(Runnable target,String name):创建新的Thread对象。
```

有关方法

```
void start():启动线程，并执行对象的run()方法。
run():线程在被调度时执行的操作。
String getName(): 返回线程的名称。
void setName(String name)设置该线程名称。
static Thread currentThread():返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类。
static void yield():线程让步
	暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程。
	若队列中没有同优先级的线程，忽略此方法。
join():当某个程序执行流中调用其他线程的 join()方法时，调用线程将被阻塞，直到join()方法加入的join线程执行完为止。
	低优先级的线程也可以获得执行。【加塞、插队】
static void sleep(long millis): 指定时间毫秒
	令当前活动线程在指定时间段内放弃对CPU控制，使其他线程有机会被执行，时间到后重排队。
	抛出InterruptedException异常
stop():强制线程生命期结束【不推荐使用！！！】
boolean isAlive():返回boolean，判断线程是否还活着。
```

JDK1.5之前创建新执行线程有两种方法：继承Thread类的方式、实现Runnable接口的方式

### 方式一

创建一个继承自Thread类的对象，重写run方法。把该对象实例化，调用start()即可启动。

```
1)定义子类继承Thread类。
2)子类中重写Thread类中的run方法。
3)创建Thread子类对象，即创建了线程对象。
4)调用线程对象start方法：启动线程，调用run方法。
```

注意点：

```
1.如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。
2.run方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定 。
3.想要启动多线程，必须调用start方法。
4.一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“ IllegalThreadStateException。
```

### 方式二

	1)定义子类，实现Runnable接口。
	2)子类中重写Runnable接口中的run方法。
	3)通过Thread类含参构造器创建线程对象。
	4)将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中 。
	5)调用Thread类的start方法：开启线程调用Runnable子类接口的run方法。
### 两种方式的对比

区别
	继承Thread：线程代码存放Thread子类run方法中。
	实现 Runnable：线程代码存在接口的子类的run方法。
**实现Runnable方式的好处**
	避免了单继承的局限性。
	多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。

### 线程调度

调度策略：时间片、抢占式(高优先级的线程抢占CPU)

Java的调度方法：同优先级线程组成先进先出队列(先到先服务)，使用时间片策略；对高优先级，使用优先调度的抢占式策略。

### 线程优先级

优先级等级：MAX_PRIORITY 10、MIN PRIORITY 1、NORM_PRIORITY 5

getPriority () 返回线程优先值；setPriority(int newPriority)改变线程的优先级。

线程创建时继承父线程的优先级；低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用。

### 守护线程

Java中的线程分为两类：一种是守护线程 ，一种是用户线程。

它们在几乎每个方面都是相同的，唯一的区别是判断 JVM 何时离开。

守护线程是用来服务用户线程的，通过在 start() 方法前调用；thread.setDaemon(true)可以把一个用户线程变成一个守护线程。

Java垃圾回收就是一个典型的守护线程。若JVM中都是守护线程，当前JVM将退出。

## 线程生命周期

Thread.java内的public enum State {}

线程对象的一个完整的生命周期中通常要经历如下的五种状态：
	新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。
	就绪：处于新建状态的线程被 start() 后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源。
	运行：当就绪的线程被调度并获得CPU资源时便进入运行状态，run()方法定义了线程的操作和功能。
	阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态。
	死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束。

![image-20220202152326507](./assets/java/image-20220202152326507.png)

## 线程同步

目的：解决线程安全问题(余额3000，两个提款机同时取2000，都通过了余额检查判断取出了钱)

### 方式一：同步代码块

效率低，因为这还是会进方法内，可能存在无必要的等待。

```java
synchronized (对象){
	//需要被同步的代码；
}
/**1.操作共享数据的代码，即为需要被同步的代码。-->不能包含代码多了，也不能包含代码少了。
 * 2.共享数据：多个线程共同操作的同一个变量。比如：ticket就是共享数据。
 * 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。
 * 要求：多个线程必须要共用同一把锁。
 */
```

### 方式二：同步方法

```java
public synchronized void show(String name){
	... ...
}
```

### 同步机制中的锁

对于并发工作，你需要某种方式来防止两个任务访问相同的资源(其实就是共享资源竞争)。防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了。而在其被解锁之时，另一个任务就可以锁定并使用它了。

synchronized 的锁是什么？
	任意对象都可以作为同步锁。所有对象都自动含有单一的锁监视器。
	**同步方法的锁：静态方法(类名.class)、非静态方法(this)**
	同步代码块：自己指定，很多时候也是指定为this或类名.class

注意：
	必须确保使用同一个资源的 多个线程共用一把锁 这个非常重要 否则就无法保证共享资源的安全
	一个线程类中的所有静态方法共用同一把锁 类名 class 所有非静态方法共用同一把锁 this 同步代码块 指定需谨慎

### 死锁

不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁

出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续

解决方法
	专门的算法、原则
	尽量减少同步资源的定义
	尽量避免嵌套同步

### 方式三：Lock锁

JDK5.0增加的特性，提供了更强大的线程同步机制 通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。

java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源之前应先获得 Lock 对象。

ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义， 在实现线程安全的控制中，比较常用的是 ReentrantLock可以显式加锁、释放锁 。

### synchronized 与 Lock的异同

相同：二者都可以解决线程安全问题

不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器
		synchronized是隐式锁(出了作用域自动释放)，Lock是显式锁[手动的启动同步lock()，同时结束同步也需要手动的实现unlock()]
		Lock只有代码块锁，synchronized有代码块锁和方法锁
		使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)

优先使用顺序：Lock—>同步代码块(已经进入了方法体，分配了相应资源)—>同步方法(在方法体之外)

## 线程通信

三个方法：
	wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。
	notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。
	notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。
	说明：
		三个方法必须使用在同步代码块或同步方法中。
		三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常
		三个方法是定义在java.lang.Object类中。

sleep() 和 wait()的异同？
	相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。
	不同点：1)两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()
         2)调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中
         3)关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。

## 线程创建方式三

实现Callable 接口

与使用Runnable相比，Callable功能更强大些
	相比run()方法，可以有返回值。
	方法可以抛出异常。
	支持泛型的返回值。
	需要借助FutureTask类，比如获取返回结果。

Future 接口
	可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。
	FutrueTask是Futrue接口的唯一的实现类。
	FutureTask同时实现了Runnable,Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。

具体流程

```java
//1.创建一个实现Callable的实现类
public class CallableTest implements Callable {
    //2.实现call方法，将此线程需要执行的操作声明在call()中
    @Override
    public Object call() throws Exception {
        return null;
    }
}
class CallableThread{
    public static void main(String[] args) {
        //3.创建Callable接口实现类的对象
        CallableTest ct = new CallableTest();
        //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask ft = new FutureTask(ct);
        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
        new Thread(ft).start();
        //6.获取Callable中call方法的返回值
        Object sum = ft.get(); //get方法需要处理异常.
    }
}
```

## 线程创建方式四

使用线程池

经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大 。

提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似公共交通。

好处
	1.提高响应速度(减少了创建新线程的时间)
	2.降低资源消耗(重复利用线程池中线程，不需要每次都创建)
	3.便于线程管理
 	    corePoolSize：核心池的大小
	     maximumPoolSize：最大线程数
	     keepAliveTime：线程没有任务时最多保持多长时间后会终止

JDK5.0起提供了线程池相关API：ExecutorService和Executors
	ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor
		void execute(Runnable command)：执行任务命令，没有返回值，一般用来执行Runnable
		<T> Future<T> submit(Callable<T> task)：执行任务，有返回值，一般用来执行Callable
		void shutdown()：关闭连接池
	Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池
		Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池
		Executors.newFixedThreadPool(n)：创建一个可重用固定线程数的线程池
		Executors.newSingleThreadExecutor()：创建一个只有一个线程的线程池
		Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。

使用流程

```java
class NumberThread implements Runnable{
    @Override
    public void run() {}
}
class NumberThread1 implements Runnable{
    @Override
    public void run() {}
}
public class ThreadPool {
    public static void main(String[] args) {
    	//1. 提供指定线程数量的线程池
    	ExecutorService service = Executors.newFixedThreadPool(10);
    	
    	//4.设置线程池的属性
        //System.out.println(service.getClass());
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
    	service1.setCorePoolSize(15);
    	service1.setKeepAliveTime();
		
    	//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
    	service.execute(new NumberThread());//适合适用于Runnable
    	service.execute(new NumberThread1());//适合适用于Runnable
   	 	//service.submit(Callable callable);//适合使用于Callable
		
    	//3.关闭连接池
    	service.shutdown();
    }
}
```

//线程池这里能通过CV简单使用。看JAVA源码的具体实现，我还是没能力的！20220202 2232

# 0X02、Java常用类

## 字符串相关的类

### String类

源码分析

```Java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {}
/**
	1.String声明为final的，不可被继承
	2.String实现了Serializable接口：表示字符串是支持序列化的。
		实现了Comparable接口：表示String可以比较大小
	3.String内部定义了final char[] value用于存储字符串数据
	4.String:代表不可变的字符序列。简称：不可变性。
		4.1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
		4.2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
		4.3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
	5.通过字面量的方式(区别于new)给一个字符串赋值，此时的字符串值声明在字符串常量池中，使用一对""引起来表示。
	6.字符串常量池中是不会存储相同内容的字符串的。
*/
```

不同声明方式

​	字面量定义：值存储在方法区里的常量池。

​	new + 构造器：new出来的都放在堆里，但是堆会指向字符串真正存储的地方-常量池(构造器地使用可以看源码、看文档里)

```java
String str1 = "abc"
String str2 = new String("abc")
```

<img src= ./assets/java/image-20220205114917364.png width=50% />

字符串拼接：

​	常量与常量的拼接结果在常量池 (仅有字面量时)。

​	只要其中有一个是变量，结果就在堆中。

​	如果拼接的结果调用 intern() 方法，返回值就在常量池中。

```java
String s1 = "javaEE";
String s2 = "hadoop";
String s3 = "javaEEhadoop";
String s4 = "javaEE" + "hadoop";
String s5 = s1 + "hadoop";
String s6 = "javaEE" + s2;
String s7 = s1 + s2;
System.out.println(s3 == s4);//true
System.out.println(s3 == s5);//false
System.out.println(s3 == s6);//false
System.out.println(s3 == s7);//false
System.out.println(s5 == s6);//false
System.out.println(s5 == s7);//false
System.out.println(s6 == s7);//false
String s8 = s6.intern();
System.out.println(s3 == s8);//true
```

<img src= ./assets/java/image-20220205115643688.png width=30% />

String使用陷阱

```
String s1 = " a";	//在字符串常量池中创建了一个字面量为a的字符串。
s1 = s1 + "b";		//实际上原来的"a"字符串对象已经丢弃了，现在在堆空间中产生了一个字符串"ab" 。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能 。
String s2 = "ab";	//直接在字符串常量池中创建一个字面量为"ab"的字符串。
String s3 = "a" + "b";	//s3指向字符串常量池中已经创建的"ab"的字符串 。
String s4 = s1.intern();	//堆空间的s1对象在调用intern()之后，会将常量池中已经存在的"ab"字符串赋值给s4 。
```

JVM的不同实现下的String

不同版本和不同实现的JVM对堆的划分不同，字符串常量池所在区域时常变动。

### String常用方法

【基本】

```java
int length(); 				//返回字符串的长度。return value.length
char charAt(int index); 	// 返回某索引处的字符。return value[index]
boolean isEmpty(); 			//判断是否是空字符串。return value.length == 0
String toLowerCase(); 		//使用默认语言环境，将 String 中的所有字符转换为小写
String toUpperCase();		//使用默认语言环境，将 String 中的所有字符转换为大写
String trim(); 	//返回字符串的副本，忽略前导空白和尾部空白
boolean equals(Object obj); //比较字符串的内容是否相同
boolean equalsIgnoreCase(String anotherString); //与equals方法类似，忽略大小写
String concat(String str); 	//将指定字符串连接到此字符串的结尾。 等价于用“+”
int compareTo(String anotherString); //比较两个字符串的大小
String substring(int beginIndex); 	//返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。
String substring(int beginIndex, int endIndex) ; //返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。
```

【索引】

```java
boolean endsWith(String suffix);	//测试此字符串是否以指定的后缀结束
boolean startsWith(String prefix);	//测试此字符串是否以指定的前缀开始
boolean startsWith(String prefix, int toffset);	//测试此字符串从指定索引开始的子字符串是否以指定前缀开始
boolean contains(CharSequence s);//当且仅当此字符串包含指定的 char 值序列时，返回 true
int indexOf(String str); 	//返回指定子字符串在此字符串中第一次出现处的索引
int indexOf(String str, int fromIndex); //返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始
int lastIndexOf(String str); //返回指定子字符串在此字符串中最后出现处的索引
int lastIndexOf(String str, int fromIndex); //返回指定子字符串在此字符串中最后一次出现处的索引，从0到指定索引搜索
//注：indexOf和lastIndexOf方法如果未找到都是返回-1
```

【替换】

```java
//返回一个新的字符串，它是通过用newChar替换此字符串中出现的所有oldChar得到的。
String replace(char oldChar, char newChar);
//使用指定的值替换此字符串所有匹配目标序列的子字符串
String replace(CharSequence target, CharSequence replacement);
//使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串。
String replaceAll(String regex, String replacement);
//使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串
String replaceFirst(String regex, String replacement);
```

【匹配】

```java
//告知此字符串是否匹配给定的正则表达式。
boolean matches(String regex);
```

【切片】

```java
//根据给定正则表达式的匹配拆分此字符串。
String[] split(String regex);
//根据给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。
String[] split(String regex, int limit);
```

### String类的转换

①String 与 基本数据类型、包装类

②字符数组 与 字符串

```Java
String str1 = "abc123";
char[] charArray = str1.toCharArray();
char[] arr = new char[]{'h','e','l','l','o'};
String str2 = new String(arr);
```

③字节数组 与 字符串

```Java
String str1 = "abc123中国";
byte[] bytes = str1.getBytes();//使用默认的字符集，进行编码。
byte[] gbks = str1.getBytes("gbk");//使用gbk字符集进行编码。
String str2 = new String(bytes);//使用默认的字符集，进行解码。
String str3 = new String(gbks);//出现乱码。原因：编码集和解码集不一致！
String str4 = new String(gbks, "gbk");//没有出现乱码。原因：编码集和解码集一致！
```

### StringBuffer和StringBuilder

StringBuffer、StringBuilder与String的区别在于前两者可以变长。他们源码实现都是char[]，区别在于有没有final声明。

StringBuffer 和 StringBuilder 区别在于，前者线程安全但是效率低，后者线程不安全但效率高。

StringBuffer 和 StringBuilder声明后默认char长度为16【阅读源码可知】，length方法获取的是已存入字符计数count！

扩容问题：阅读AbstractStringBuilder.java源码里的ensureCapacity、ensureCapacityInternal、newCapacity方法

【有IDE做开发真的是效率高，包括源码阅读也是，方便跳转、查看。而且学习计算机真的得英语好，看文档和源码注释！】

【自己看完源码之后，才看的视频，大差不差！】

### StringBuffer常用方法

StringBuilder和StringBuffer没其他区别了几乎

执行效率从高到低排列：StringBuilder > StringBuffer > String

```java
StringBuffer append(xxx)//提供了很多的append()方法，用于进行字符串拼接
StringBuffer delete(int start,int end)//删除指定位置的内容
StringBuffer replace(int start, int end, String str)//把[start,end)位置替换为str
StringBuffer insert(int offset, xxx)//在指定位置插入xxx
StringBuffer reverse() //把当前字符序列逆转
//当append和insert时，如果原来value数组长度不够，可扩容。
//如上这些方法支持"方法链"操作。

public int indexOf(String str)
public String substring(int start,int end)//返回一个[start,end)区间索引的子字符串
public int length()
public char charAt(int n )
public void setCharAt(int n ,char ch)
//所有涉及区间的都是左闭右开！！！
```

总结：
	增：append(xxx)
	删：delete(int start,int end)
	改：setCharAt(int n ,char ch) / replace(int start, int end, String str)
	查：charAt(int n )
	插：insert(int offset, xxx)
	长度：length();
	遍历：for() + charAt() / toString()

## JDK8前日期时间 API

计算世界时间的主要标准有：UTC(Coordinated Universal Time)、GMT(Greenwich Mean Time)、CST(Central Standard Time)

我在东八区 UTC+8

时间戳：当前时间与1970年1月1日0时0分0秒之间的时间差，以毫秒为单位

```java
long time = System.currentTimeMillis();	//获取时间戳
```

### Date类

java.util.Date类与java.sql.Date类冲突，需要手动选择

```java
1.两个构造器的使用
	构造器一：Date()：创建一个对应当前时间的Date对象
	构造器二：创建指定毫秒数的Date对象
2.两个方法的使用
	toString():显示当前的年、月、日、时、分、秒
	getTime():获取当前Date对象对应的毫秒数。
3. java.sql.Date对应着数据库中的日期类型的变量
	如何实例化：java.sql.Date date = new java.sql.Date(1644060360814L);
	如何将java.util.Date对象转换为java.sql.Date对象
    	//本质为时间戳。通过getTime()获取java.util.Date类的时间，再新建java.sql.Date传入！
      	Date date6 = new Date();
        java.sql.Date date7 = new java.sql.Date(date6.getTime());
```

### SimpleDateFormat类

```Java
//实例化1：SimpleDateFormat:使用默认的构造器
SimpleDateFormat sdf = new SimpleDateFormat();

// 2.1格式化：日期 --->字符串
Date date = new Date();
String format = sdf.format(date);

// 2.2格式化的逆过程：字符串 ---> 日期
String str = "2022-02-06 下午07:05";
Date date1 = sdf.parse(str);

//按照指定的方式格式化和解析：调用带参的构造器
SimpleDateFormat sdf1 = new SimpleDateFormat("MM/dd/yyyy hh:mm:ss);
//格式化
String format1 = sdf1.format(date);
//解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),否则，抛异常
Date date2 = sdf1.parse("02/06/2022 19:21:27");
```

### Calendar类

Calendar 是一个抽象基类，主用用于完成日期字段之间相互操作的功能

获取 Calendar 实例的方法：使用 Calendar.getInstance()方法；调用它的子类 GregorianCalendar的构造器。

```Java
//1.实例化
//方式一：创建其子类(GregorianCalendar)的对象
//方式二：调用其静态方法getInstance()
Calendar calendar = Calendar.getInstance();
System.out.println(calendar.getClass());

//2.常用方法
//get()
System.out.println(calendar.get(Calendar.DAY_OF_MONTH));	//这个月底几天
System.out.println(calendar.get(Calendar.DAY_OF_YEAR));	//今年底几天

//set()
//calendar可变性
calendar.set(Calendar.DAY_OF_MONTH,22);	//修改为这个月第22天，数字大于31怎么办？
System.out.println(calendar.get(Calendar.DAY_OF_MONTH));

//add()
calendar.add(Calendar.DAY_OF_MONTH,-3);	//对DAY-3
calendar.add(Calendar.MONTH,+3);	//对月份+3
System.out.println(calendar.get(Calendar.DAY_OF_MONTH));

//getTime():日历类---> Date
Date date = calendar.getTime();
System.out.println(date);

//setTime():Date ---> 日历类
Date date1 = new Date();
calendar.setTime(date1);
System.out.println(calendar.get(Calendar.DAY_OF_MONTH));
```

获取月份时： 一月是0，二月是1 ，以此类推12月是11
获取星期时： 周日是1，周二是2 。 。。。周六是7

## JDK8新日期时间 API

### 旧版API的缺点

​	可变性：像日期和时间这样的类应该是不可变的。【旧版无返回值，直接修改】
​	偏移性：Date 中的年份是从 1900 开始的，而月份都从0开始。【初始化的含参构造器，年份减去1900，月份减去1】
​	格式化：格式化只对Date 有用， Calendar 则不行。
​	此外，它们也不是线程安全的；不能处理闰秒等。

```
Date date = new Date(2022 - 1900,2 - 1,8);
System.out.println(date);//Tue Feb 08 00:00:00 CST 2022
```

### Java.Time

​	包吸收了Joda-Time的优秀特点
​	java.time包含值对象的基础包
​	java.time.chrono提供对不同的日历系统的访问
​	java.time.format格式化和解析时间和日期
​	java.time.temporal包括底层框架和扩展特性
​	java.time.zone包含时区支持的类

LocalDate 、 LocalTime 、 LocalDateTime 类是其中较重要的几个类，它们的实例是不可变的对象。
	LocalDate 代表 IOS 格式( yyyy MM dd )的日期 可以存储 生日、纪念日等日期。
	LocalTime 表示一个时间，而不是日期 。
	LocalDateTime 是用来表示日期和时间的， 这是一个最常用的类之一。
	注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。

### LocalDate类

![image-20220206210529539](./assets/java/image-20220206210529539.png)

不可变性

```java
LocalDateTime localDateTime3 = localDateTime.plusMonths(3);
System.out.println(localDateTime);
System.out.println(localDateTime3);
```

### Instant

概念
​	时间线上的一个瞬时点，精度可以达到纳秒级。
​	表示自1970年1月1日0时0分0秒"UTC" 开始的秒数。这可被用来记录应用程序中的事件时间戳 。

![image-20220206212625393](./assets/java/image-20220206212625393.png)

```Java
 //now():获取本初子午线对应的标准时间
 Instant instant = Instant.now();
 System.out.println(instant);//2022-02-06T13:28:26.424Z

//添加时间的偏移量
OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));
System.out.println(offsetDateTime);//2022-02-06T21:28:26.424+08:00

//toEpochMilli():获取自1970年1月1日0时0分0秒(UTC)开始的毫秒数  ---> Date类的getTime()
long milli = instant.toEpochMilli();
System.out.println(milli);

//ofEpochMilli():通过给定的毫秒数，获取Instant实例  -->Date(long millis)
Instant instant1 = Instant.ofEpochMilli(1644154106424L);
System.out.println(instant1);
```

### DateTimeFormatter

java.time.format.DateTimeFormatter

预定义的标准格式。如：ISO_LOCAL_DATE_TIME、ISO_LOCAL_DATE、ISO_LOCAL_TIME
本地化相关的格式。如： ofLocalizedDateTime(FormatStyle.LONG)
自定义的格式。如： ofPattern(“yyyy MM dd hh:mm:ss”)

![image-20220206215730572](./assets/java/image-20220206215730572.png)

```Java
//方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME
DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
//格式化:日期-->字符串
LocalDateTime localDateTime = LocalDateTime.now();
String str1 = formatter.format(localDateTime);
//解析：字符串 -->日期
TemporalAccessor parse = formatter.parse("2022-02-06T22:03:50.043");

//方式二：本地化相关的格式。如：ofLocalizedDateTime()
//FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime
DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);
String str2 = formatter1.format(localDateTime);	//格式化

//本地化相关的格式。如：ofLocalizedDate()
//FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate
DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM);
String str3 = formatter2.format(LocalDate.now());	//格式化

//【重点】方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)
DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss");
String str4 = formatter3.format(LocalDateTime.now());	//格式化
TemporalAccessor accessor = formatter3.parse("2022-02-06 10:04:26");	//解析
```

## Java比较器

说明
​	Java中的对象，正常情况下，只能进行比较：==  或  != 。不能使用 > 或 < 的
​	但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。
​	如何实现？使用两个接口中的任何一个：Comparable 或 Comparator

Comparable接口与Comparator的使用的对比：
​	Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。
​	Comparator接口属于临时性的比较。

### Comparable接口
​	【自然排序】
​	像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。
​	像String、包装类重写compareTo()方法以后，进行了从小到大的排列
​	重写compareTo(obj)的规则：
​		如果当前对象this大于形参对象obj，则返回正整数；
​		如果当前对象this小于形参对象obj，则返回负整数；
​		如果当前对象this等于形参对象obj，则返回零。
​		最好使自然排序与 equals 一致

​	对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。
​		在compareTo(obj)方法中指明如何排序?

### Comparator接口
【定制排序】
	当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码
	或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序
	将Comparator传递给sort方法(如 Collections.sort 或 Arrays.sort)从而允许在排序顺序上实现精确控制
	还可以使用Comparator来控制某些数据结构(如有序 set 或有序映射)的顺序
	为那些没有自然顺序的对象 collection 提供排序 。

重写compare(Object o1,Object o2)方法，比较o1和o2的大小：
​		如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。

```Java
String arr[] = new String[]{"AA","CC","KK","MM","GG","JJ","DD"};
Arrays.sort(arr);	//String类内部实现了Comparable接口了
System.out.println(Arrays.toString(arr));
// 因为对象无法比较大小，但是实际又有这种需求。
// 我们通过写一个方法，告诉sort方法如何比较两个同类对象比大小，sort实现算法其他部分并不受影响

//使用Comparator对象临时修改排序规则
Arrays.sort(arr,new Comparator(){
    //按照字符串从大到小的顺序排列
    @Override
    public int compare(Object o1, Object o2) {
        if(o1 instanceof String && o2 instanceof  String){
            String s1 = (String) o1;
            String s2 = (String) o2;
            return -s1.compareTo(s2);   //改为从大到小
        }
        //                return 0;
        throw new RuntimeException("输入的数据类型不一致");
    }
});
```

## System类

System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包 。
	由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。
	其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。

### 成员变量

​	in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。

### 成员方法

​	native long currentTimeMillis()：该方法的作用是返回当前计算机的时间戳
​	void exit(int status)：
​		该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。 
​		使用该方法可以在图形界面编程中实现程序的退出功能等。
​	void gc()
​		该方法的作用是请求系统进行垃圾回收。
​		至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。
​	String getProperty(String key)
​		该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：

![image-20220207003619296](./assets/java/image-20220207003619296.png)

```Java
String javaVersion = System.getProperty("java.version");
String javaHome = System.getProperty("java.home");
String osName = System.getProperty("os.name");
String osVersion = System.getProperty("os.version");
String userName = System.getProperty("user.name");
String userHome = System.getProperty("user.home");
String userDir = System.getProperty("user.dir");
```

## Math类

java.lang.Math提供了一系列静态方法用于科学计算。

其方法的参数和返回值类型一般为double型。

```Java
abs	//绝对值
acos,asin,atan,cos,sin,tan	//三角函数
sqrt	//平方根
pow(double a,doble b) 	//a的b次幂
log		//自然对数
exp 	//e为底指数
max(double a,double b)
min(double a,double b)
random()	//返回0.0到1.0的随机数
long round(double a) 	//double型数据a转换为long型(四舍五入)
toDegrees(double angrad)	//弧度->角度
toRadians(double angdeg)	//角度->弧度
```

## BigInteger

由于int、long可存储的数字长度有限，而此类可以表示不可变的任意精度的整数。

BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。

BigInteger 还提供以下运算：模算术、 GCD 计算、质数测试、素数生成、位操作以及一些其他操作。

构造器：BigInteger(String val);  根据字符串构建 BigInteger 对象

```java
//常用方法
public BigInteger abs():返回此BigInteger的绝对值的BigInteger。
BigInteger add(BigInteger val):返回其值为(this + val)的BigInteger。
BigInteger subtract(BigInteger val):返回其值为(this val)的BigInteger。
BigInteger multiply(BigInteger val):返回其值为(this * val)的BigInteger。
BigInteger divide(BigInteger val):返回其值为(this / val)的BigInteger。整数相除只保留整数部分。
BigInteger remainder(BigInteger val):返回其值为 (this % val)的BigInteger。
BigInteger [] divideAndRemainder(BigInteger val):返回包含(this/val)后跟(this%val)的两个BigInteger的数组。
BigInteger pow(int exponent):返回其值为(this exponent)的BigInteger。
```

## BigDecimal

一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类 。

构造器
	public BigDecimal(double val)
	public BigDecimal(String val)

常用方法
	public BigDecimal add(BigDecimal)
	public BigDecimal subtract(BigDecimal)
	public BigDecimal multiply(BigDecimal)
	public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)

# 0X03、枚举类

使用场景：类的对象是有限确定的，那么就称此类可用枚举类(单例模式)；当需要定义一组常量时，强烈建议使用枚举类。

```
星期：Monday(星期一)、... ...、Sunday(星期天)
性别：Man(男)、Woman(女)
季节：Spring(春节).....Winter(冬天)
支付方式：Cash(现金)、WeChatPay(微信)、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)
就职状态：Busy、Free、Vocation、Dimission
订单状态：Nonpayment(未付款)、Paid(已付款)、Delivered(已发货)、Return(退货)、Checked(已确认)、Fulfilled(已配货)、
线程状态：创建、就绪、运行、阻塞、死亡
```

方式一：jdk5.0之前，自定义枚举类

方式二：jdk5.0，可以使用enum关键字定义枚举类【1.5和1.8的更新很重大！】

## 自定义枚举类

自己写代码实现枚举特性。

```Java
public class SeasonTest {
    public static void main(String[] args) {
        Season spring = Season.SPRING;
        System.out.println(spring);
    }
}
class Season {
    //1.声明Season对象的属性:private final修饰,在构造器中初始化
    private final String seasonName;
    private final String seasonDesc;
    //2.私有化类的构造器,类的构造器，保证不能在类的外部创建其对象
    private Season(String seasonName,String seasonDesc){
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }
    //3.在类的内部创建枚举类的实例。声明为：public static final。
    public static final Season SPRING = new Season("春天","春暖花开");
    public static final Season SUMMER = new Season("夏天","夏日炎炎");
    public static final Season AUTUMN = new Season("秋天","秋高气爽");
    public static final Season WINTER = new Season("冬天","冰天雪地");
    //4.其他诉求1：获取枚举类对象的属性
    public String getSeasonName() {
        return seasonName;
    }
    public String getSeasonDesc() {
        return seasonDesc;
    }
    //4.其他诉求2：提供toString()
    @Override
    public String toString() {
        return "Season{" +
                "seasonName='" + seasonName + '\'' +
                ", seasonDesc='" + seasonDesc + '\'' +
                '}';
    }
}
```

## 关键字enum

定义的枚举类默认继承于java.lang.Enum类

枚举类的构造器只能使用 private 权限修饰符

枚举类的所有实例必须在枚举类中显式列出 (, 分隔 ; 结尾) 。列出的实例系统会自动添加public static final修饰

必须在枚举类的第一行声明枚举类对象

```java
enum Season2 {
    //1.提供当前枚举类的对象，多个对象之间用","隔开，末尾对象";"结束
    SPRING("春天","春暖花开"),
    SUMMER("夏天","夏日炎炎"),
    AUTUMN("秋天","秋高气爽"),
    WINTER("冬天","冰天雪地");

    //2.声明Season对象的属性:private final修饰
    private final String seasonName;
    private final String seasonDesc;

    //3.私有化类的构造器,并给对象属性赋值
    private Season2(String seasonName,String seasonDesc){
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    }
    
    //4.其他诉求1：获取枚举类对象的属性
    public String getSeasonName() {
        return seasonName;
    }
    public String getSeasonDesc() {
        return seasonDesc;
    }
    //4.其他诉求2：toString()自动提供，一般就不写了
}
```

JDK1.5中可以在switch表达式中使用Enum定义的枚举类的对象作为表达式，case子句可以直接使用枚举值的名字。

## Enum类的主要方法

values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。

valueOf(String str)：把一个字符串转为对应枚举类的对象。要求字符串必须是枚举类对象的“名字”。否则会有IllegalArgumentException

toString()：返回当前枚举类对象常量的名称

## Enum类实现接口

和普通Java类一样，枚举类可以实现一个或多个接口

情况一：实现接口，在enum类中实现抽象方法【每个枚举值在调用实现的接口方法呈现相同的行为方式】

情况二：让枚举类的对象分别实现接口中的抽象方法【每个枚举值在调用实现的接口方法呈现出不同的行为方式】

# *0x04注解

## 注解概述

Annotation概念
	其实就是代码里的特殊标记,这些标记可以在编译,类加载 , 运行时被读取,并执行相应的处理。
	通过使用Annotation, 程序员可以在不改变原有逻辑的情况下,在源文件中嵌入一些补充信息。
Annotation功能
	代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。
	可以像修饰符一样被使用,可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。
	在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。
	在JavaEE/Android中注解占据了重要角色，例如用来配置应用程序的任何切面，代替旧版中所遗留的繁冗代码和XML配置等。
	未来的开发模式都是基于注解的，注解是一种趋势。一定程度上可以说【框架=注解+反射+设计模式】
Annotation使用
	在其前面增加@符号,并把该Annotation当成一个修饰符使用。用于修饰它支持的程序类型。

## 常见Annotation示例

示例一：生成文档相关的注解

```java
@author标明开发该类模块的作者，多个作者之间使用,分割
@version标明该类模块的版本
@see参考转向 也就是相关主题
@since从哪个版本开始增加的
@param对方法中某参数的说明 如果没有参数就不能写
@return对方法返回值的说明 如果方法的返回值类型是void就不能写
@exception对方法可能抛出的异常进行说明 如果方法没有用throws显式抛出的异常就不能写
其中
	@param、@return和@exception这三个标记都是只用于方法的。
	@param的格式要求：@param 形参名 形参类型 形参说明
	@return的格式要求：@return 返回值类型 返回值说明
	@exception的格式要求：@exception 异常类型 异常说明
	@param和@exception可以并列多个
```

生成文档，给程序员提供API信息。

示例二：在编译时进行格式检查(JDK内置的三个基本注解)

```java
@Override:限定重写父类方法,该注解只能用于方法。	//用于校验，帮助程序员的！
@Deprecated:用于表示所修饰的元素类,方法等已过时。通常是因为所修饰的结构危险或存在更好的选择。
@SuppressWarnings:抑制编译器警告。
```

示例三：跟踪代码依赖性，实现替代配置文件功能
​	Servlet3.0提供了注解,使得不再需要在web.xml文件中进行Servlet的部署。
​	spring框架中关于"事务"的管理。

## 自定义Annotation

参照@SuppressWarnings定义
	① 注解声明为：@interface
	② 内部定义成员，通常使用value表示
	③ 可以指定成员的默认值，使用default定义
	④ 如果自定义注解没有成员，表明是一个标识作用。

如果注解有成员，在使用注解时，需要指明成员的值。
自定义注解必须配上注解的信息处理流程(使用反射)才有意义。
自定义注解通过都会指明两个元注解：Retention、Target
自定义注解自动继承了java.lang.annotation.Annotation接口

Annotation的成员变量
	在Annotation定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。
	类型只能是：八种基本数据类型、String类型、Class类型、enum类型、Annotation类型以及以上所有类型的数组。
	可以在定义Annotation的成员变量时为其指定初始值，指定成员变量的初始值可使用default关键字
	如果只有一个参数成员，建议使用参数名为value
​	包含成员变量的Annotation称为元数据Annotation
​	如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是"参数名=参数值"，如果只有一个参数成员，且名称为value，可以省略"value="。

## JDK中的元注解

jdk提供的4种元注解,元注解：对现有的注解进行解释说明的注解

Retention
	指定所修饰的 Annotation 的生命周期：SOURCE\CLASS(默认行为)\RUNTIME【RetentionPolicy.java注释说明】
	只有声明为RUNTIME生命周期的注解，才能通过反射获取。

Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素

![image-20220207140106515](./assets/java/image-20220207140106515.png)

Documented:表示所修饰的注解在被javadoc解析时，保留下来。【出现的频率较低】

Inherited:被它修饰的 Annotation 将具有继承性。【出现的频率较低】

## 利用反射获取注解信息

略，放到后边。整个注解的内容得到实际开发、应用框架的时候感受得到。

## JDK8注解新特性

可重复注解
	① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class。
	② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。
	③ MyAnnotations里声明了MyAnnotation[] value();

类型注解
	ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中(如：泛型声明)。
	ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。

# *0X05、集合

## Java集合

### 概述

一方面，面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。

另一方面，使用Array存储对象方面具有一些弊端，而Java集合就像一种容器，可以动态地把多个对象的引用放入容器中。

数组在内存存储方面的特点：
	数组初始化以后，长度就确定了。
	数组声明的类型，就决定了进行元素初始化时的类型

数组在存储数据方面的弊端：
	数组初始化以后，长度就不可变了，不便于扩展
	数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。
	无法直接获取实际存储元素的个数。
	数组存储的数据是有序的、可以重复的。存储数据类型单一。【对于无序、不可重复的需求，不能满足】

Java集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。

### 两个体系

Java集合可分为Collection和Map两种体系

Collection接口单列数据， 定义了存取一组对象的方法的集合
	List元素有序、可重复的集合
	Set元素无序、不可重复的集合
	
![image-20220207152058161](./assets/java/image-20220207152058161.png)

|----Collection接口：单列集合，用来存储一个一个的对象
	|----List接口：存储有序的、可重复的数据。  -->“动态”数组
		|----ArrayList、LinkedList、Vector
	|----Set接口：存储无序的、不可重复的数据   -->中学数学里讲的“集合”
		|----HashSet、LinkedHashSet、TreeSet

Map接口：双列数据，保存具有映射关系"key value对"的集合【map可看作python里的字典】

![image-20220207152227442](./assets/java/image-20220207152227442.png)

|----Map接口：双列集合，用来存储一对(key - value)一对的数据   -->中学数学里的映射：y = f(x)
	|----HashMap、LinkedHashMap、TreeMap、Hashtable、Properties

## Collection接口方法

Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和Queue集合。

JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。

在Java5之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理

从JDK5增加了泛型以后，Java集合可以记住容器中对象的数据类型。

```Java
1、添加
	add(Object obj)
	addAll(Collection coll)
2、获取有效元素的个数
	int size()
3、清空集合
	void clear()
4、是否是空集合
	boolean isEmpty()
5、是否包含某个元素
	boolean contains(Object obj)是通过元素的equals方法来判断是否是同一个对象
	boolean containsAll(Collection c)也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。
6、删除
	boolean remove(Object obj) 通过 元素的 equals 方法判断是否是要删除的那个元素。只会删除找到的第一个元素
	boolean removeAll(Collection coll)取当前集合的差集
7、取两个集合的交集
	boolean retainAll(Collection c) 把交集的结果存在当前集合中，不影响c
8、集合是否相等
	boolean equals(Object obj)
9、转成对象数组
	Object[] toArray()
10、获取集合对象的哈希值
	hashCode()
11、遍历
	iterator() 返回迭代器对象，用于集合遍历
```

向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().【让Collection方法调用equals对比内容而不是地址】

## Iterator迭代器

要对集合元素进行遍历操作，使用迭代器Iterator接口。迭代器是设计模式的一种。 

GOF 给迭代器模式的定义：提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部【这种模式为容器而生】。

Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，该方法用以返回一个实现了Iterator接口的对象。

Iterator的内部的方法：hasNext() 、next()、remove()。next()获取下一个元素，hasNext()判断是否还有下一个元素。

### 标准示例

```java
Collection coll = new ArrayList();
coll.addAll(Arrays.asList(123,456,new Person("Jerry",20),new String("Tom"),false));
//Iterator仅用于遍历集合，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。
Iterator iterator = coll.iterator();
//不推荐for结合获取coll的size来遍历，要hasNext用起来！
while(iterator.hasNext()){
	System.out.println(iterator.next());
}
```

### 错误示范

```Java
// 错误实现1：
// while((iterator.next()) != null){System.out.println(iterator.next());}

// 错误实现2：
// 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。
while (coll.iterator().hasNext()){
    System.out.println(coll.iterator().next());
}
```

迭代器的执行原理

​	当创建iterator对象后，有个指针指向list的第一个元素前一个，为空。调用一次next指针向后移动一次，指向一个元素。

### Iterator中的remove()

​	一次next()方法对应最多调用一次remove()，否则会产生IllegalStateException。注意区分这里的remove不是Collection里的

```Java
while (iterator.hasNext()){
	// iterator.remove();        // 此语句执行会报异常，因为上次循环调用过一次remove或还没有next()。
	Object obj = iterator.next();
	if("Tom".equals(obj)){
		iterator.remove();
		// iterator.remove();    // 此语句执行会报异常
	}
}
```

### 增强for循环

```Java
// for(元素类型 局部变量i : 元素集合)
// 也可用来遍历数组for(int i : int arr[]){}
for(Object obj:coll){		//debug发现，内部仍然调用了迭代器，将结果赋给临时变量obj
	System.out.println(obj);
}
```

## Collection子接口List

List集合类中元素有序、且可重复 ，集合中的每个元素都有其对应的顺序索引。可以根据索引存取容器中的元素。

JDK API 中 List 接口的实现类常用的有： ArrayList 、 LinkedList 和 Vector。

### List接口框架

```
|----Collection接口：单列集合，用来存储一个一个的对象
   |----List接口：存储有序的、可重复的数据。  -->“动态”数组,替换原有的数组
       |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] 存储
       |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高，但此类查找速度慢；底层实现是双向链表
       |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] 存储【比List接口先出现】
```

### ArrayList源码分析

本质上，ArrayList是对象引用的一个变长数组。此部分建议自己耐心细读代码：先简单看视频了解思路，后自己细读。

jdk7情况下

```Java
ArrayList list = new ArrayList();	//底层创建了长度是10的Object[]数组
list.add(123);	//elementData[0] = new Integer(123);
//...
list.add(11);	//如果此次的添加导致底层elementData数组容量不够，则扩容。
```

默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。

结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)

jdk8中ArrayList的变化：

```Java
ArrayList list = new ArrayList();	//底层Object[] elementData初始化为{}.并没有创建长度为10的数组
list.add(123);	//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]
//...
//后续的添加和扩容操作与jdk7无异。
```
jdk7中ArrayList对象的创建类似于单例饿汉式，而jdk8中ArrayList对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。

Arrays.asList(…)返回值是一个固定长度的List集合。

### LinkedList源码分析

```Java
LinkedList list = new LinkedList(); //内部声明了Node类型的first和last属性，默认值为null
list.add(123);	//将123封装到Node中，创建了Node对象。
```

其中，Node内部类的定义，体现了LinkedList的双向链表的说法

```Java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
	}
 }
```

### Vector源码分析

jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来的数组长度的2倍。

### List常用方法

List 除了从 Collection 集合继承的方法外， List 集合里添加了一些根据索引来操作集合元素的方法。

```Java
void add(int index, Object ele):在index位置插入ele元素
boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来
Object get(int index):获取指定index位置的元素
int indexOf(Object obj):返回obj在集合中首次出现的位置
int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置
Object remove(int index):移除指定index位置的元素，并返回此元素
Object set(int index, Object ele):设置指定index位置的元素为ele
List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合
```

### 常用方法总结

​    增：add(Object obj)
​    删：remove(int index) / remove(Object obj)
​    改：set(int index, Object ele)
​    查：get(int index)
​    插：add(int index, Object ele)
​    长度：size()
​    遍历：①Iterator迭代器方式；②增强for循环；③普通的循环。

面试题①

```Java
public void interViewTest(){
    List list = new ArrayList();
    list.add(1);
    list.add(2);
    list.add(3);
    updateList(list);
    System.out.println(list);   //我猜是[1，2]，不对，2是转为String了还是索引，应该是索引 1518 我对了！！
}
private void updateList(List list) {
	list.remove(2);
	//list.remove(new Integer(2));
}
```

面试题②

请问ArrayList/LinkedList/Vector的异同，谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别。

```markdown
ArrayList和LinkedList的异同
	二者都线程不安全，相对线程安全的Vector，执行效率高。
	此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
	对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。
	对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。
ArrayList和Vector的区别
	Vector和ArrayList几乎是完全相同的，唯一的区别在于Vector是强同步类(synchronized)。因此开销就比ArrayList大、访问慢。
	正常情况下大多数的Java程序员使用ArrayList而不是Vector, 因为同步完全可以由程序员自己来控制。
	Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。
	Vector还有一个子类Stack。
```

## Collection子接口Set

Set接口的框架

```
|----Collection接口：单列集合，用来存储一个一个的对象
|----Set接口：**存储无序的、不可重复的数据**   -->高中讲的“集合”
	|----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值
		|----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历
                         对于频繁的遍历操作，LinkedHashSet效率高于HashSet.
|----TreeSet：可以按照添加对象的指定属性，进行排序。
```

Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。

Set判断两个对象是否相同不是使用==运算符，而是根据 equals() 方法
​	要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()
​	要求：重写的hashCode()和equals()尽可能保持一致性：**相等的对象必须具有相等的散列码**

重写hashCode()方法的基本原则
​	在程序运行时，同一个对象多次调用hashCode() 方法应该返回相同的值。
​	当两个对象的equals()方法比较返回true时，这两个对象的hashCode()方法的返回值也应相等。
​	对象中用作equals() 方法比较的Field，都应该用来计算hashCode值。

重写equals()方法的基本原则
	复写equals方法的时候一般都需要同时复写hashCode方法。
​	通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。


### 添加元素的过程

以HashSet为例：
	我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，
	此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置(即为：索引位置)，判断
	数组此位置上是否已经有元素：
		如果此位置上没有其他元素，则元素a添加成功。 --->情况1
		如果此位置上有其他元素b(或以链表形式存在的多个元素)，则比较元素a与元素b的hash值：
			如果hash值不相同，则元素a添加成功。--->情况2
			如果hash值相同，进而需要调用元素a所在类的equals()方法：
				   equals()返回true,元素a添加失败
				   equals()返回false,则元素a添加成功。--->情况2

```java
final V putVal(***)	//HashMap.java里的这个函数太复杂了。
```

对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。
	jdk 7 :元素a放到数组中，指向原来的元素。
	jdk 8 :原来的元素在数组中，指向元素a
	总结：七上八下

### HashSet

按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。

HashSet底层：数组+链表的结构。

HashSet特点
​	无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。
​	不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。

### LinkedHashSet

LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。
优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet。【所以遍历结果显示的顺序和添加顺序一致】

LinkedHashSet 插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。

### TreeSet

TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。

TreeSet 底层使用红黑树结构存储数据。

向TreeSet中添加的数据，要求是相同类的对象。且对象的类必须实现 Comparable接口。

向 TreeSet 中添加元素时，只有第一个元素无须比较 compareTo 方法，后面添加的所有元素都会调用 compareTo 方法进行比较。

元素在集合内的顺序有两种排序方式：自然排序(实现Comparable接口)和定制排序(Comparator)
	自然排序中，比较两个对象是否相同的标准为：compareTo()返回0。不再是equals()。
	定制排序中，比较两个对象是否相同的标准为：compare()返回0。不再是equals()。

## Map接口概述

​	Map用于保存具有映射关系的数据:key-value
​	Map中的key和value都可以是任何引用类型的数据
​	Map中的key用Set来存放，不允许重复，即同一个Map对象所对应的类，须重写hashCode()和equals()方法
​	常用String类作为Map的“键”
​	key和value之间存在单向一对一关系，即通过指定的key总能找到唯一的、确定的value
​	Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是Map接口使用频率最高的实现类

Map的实现类的结构

```
|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)
       |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value
            |----LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。
                    原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。
                    对于频繁的遍历操作，此类执行效率高于HashMap。
       |----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序
                    底层使用红黑树
       |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value
            |----Properties:常用来处理配置文件。key和value都是String类型

HashMap的底层：数组+链表 (jdk7及之前)
              数组+链表+红黑树(jdk 8)
```

Map结构的理解：

 *    Map中的key:无序的、不可重复的，使用Set存储所有的key  ---> key所在的类要重写equals()和hashCode()(以HashMap为例)
 *    Map中的value:无序的、可重复的，使用Collection存储所有的value --->value所在的类要重写equals()
 *    一个键值对：key-value构成了一个Entry对象。
 *    Map中的entry:无序的、不可重复的，使用Set存储所有的entry

常用方法

```Java
//添加、删除、修改操作：
	Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中
	void putAll(Map m):将m中的所有key-value对存放到当前map中
	Object remove(Object key)：移除指定key的key-value对，并返回value
	void clear()：清空当前map中的所有数据
//元素查询的操作：
	Object get(Object key)：获取指定key对应的value
	boolean containsKey(Object key)：是否包含指定的key
	boolean containsValue(Object value)：是否包含指定的value
	int size()：返回map中key-value对的个数
	boolean isEmpty()：判断当前map是否为空
	boolean equals(Object obj)：判断当前map和参数对象obj是否相等
//元视图操作的方法：
	Set keySet()：返回所有key构成的Set集合
	Collection values()：返回所有value构成的Collection集合
	Set entrySet()：返回所有key-value对构成的Set集合
```

### 实现类HashMap

底层实现原理？(以jdk7为例说明)

```txt
HashMap map = new HashMap():
在实例化以后，底层创建了长度是16的一维数组Entry[] table。
...可能已经执行过多次put...
map.put(key1,value1):
首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。
如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1
如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据
的哈希值：
	如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2
	如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：
		如果equals()返回false:此时key1-value1添加成功。----情况3
		如果equals()返回true:使用value1替换value2。

补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。

在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。

jdk8 相较于jdk7在底层实现方面的不同：
1. new HashMap():底层没有创建一个长度为16的数组
2. jdk 8底层的数组是：Node[],而非Entry[]
3. 首次调用put()方法时，底层创建长度为16的数组
4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。
   4.1 形成链表时，七上八下(jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素)
	   4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组的长度 > 64时，此时此索引位置上的所数据改为使用红黑树存储。

DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16
DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75
threshold：扩容的临界值，=容量*填充因子：16 * 0.75 => 12
TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8
MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64
```

![image-20220215180355629](./assets/java/image-20220215180355629.png)

![image-20220215180416293](./assets/java/image-20220215180416293.png)

记住这两个图，再结合代码解读后，阅读代码更轻松一点。

### LinkedHashMap

底层实现原理(了解)，源码中：

```
static class Entry<K,V> extends HashMap.Node<K,V> {
	 Entry<K,V> before, after;//能够记录添加的元素的先后顺序
	 Entry(int hash, K key, V value, Node<K,V> next) {
		super(hash, key, value, next);
	 }
 }
```

对比HashMap中的内部类Node和LinkedHashMap中的内部类Entry

### 常用方法总结

 * 添加：put(Object key,Object value)
 * 删除：remove(Object key)
 * 修改：put(Object key,Object value)
 * 查询：get(Object key)
 * 长度：size()
 * 遍历：keySet() / values() / entrySet()

## TreeMap

向TreeMap中添加key-value，要求key必须是由同一个类创建的对象。

TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。 【按照key进行：自然排序 、定制排序】

TreeMap 可以保证所有的 Key-Value 对处于有序状态

## Hashtable

古老，略。

与HashMap实现原理相同，区别在于 Hashtable是线程安全的、Hashtable不允许值为null。

## Properties

Properties 类是 Hashtable 的子类，该对象常用来处理配置文件。key和value都是String类型

## Collections工具类

Collections 是一个操作 Set、List 和 Map 等集合的工具类
Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法

```java
//排序操作：(均为static方法)
    reverse(List)：反转 List 中元素的顺序
    shuffle(List)：对 List 集合元素进行随机排序
    sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序
    sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
    swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换
//查找、替换
    Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
    Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素
    Object min(Collection)
    Object min(Collection，Comparator)
    int frequency(Collection，Object)：返回指定集合中指定元素的出现次数
    void copy(List dest,List src)：将src中的内容复制到dest中
    boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换List对象的所有旧值
//同步控制
//提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题
```

# 0X06、泛型

## 概述

Parameterized type - generics

关于泛型的理解
		本质在于Java是强类型语言，但是有时存在代码实现不确定类型或者有多种可能类型的需要(在集合里体现明显)(而代码实现的其余部分一样)。我们通过定义一个符号代替具体的类型声明，在我们需要用到的之后指定类型即可(创建集合时再指定集合元素的类型)。

功能：

​		通过泛型的存在，可以指定集合内的元素类型，做到了类型安全的同时也为使用提供了方便。做到在编译时检测错误。

​		![image-20220215185232131](./assets/java/image-20220215185232131.png)

![image-20220215185247426](./assets/java/image-20220215185247426.png)

## 泛型结构

类型：泛型类、泛型接口、泛型方法

### 泛型类、接口

声明

```Java
interface List<T> 和 class GenTest<K,V>。
```

​	其中，T,K,V仅仅是一个符号，表示某种类型，使用任意字母都可以。

​	泛型类可有多个参数。

​	常用T是Type的缩写，只能是类，不能用基本数据类型填充。

​	构造器不声明泛型。

​	父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型，还可以增加自己的泛型。

```Java
class Father<T1, T2> {}
// 子类不保留父类的泛型
// 1)没有类型 擦除
class Son<A, B> extends Father{//等价于class Son extends Father<Object,Object>{}
// 2)具体类型
class Son2<A, B> extends Father<Integer, String> {}
// 子类保留父类的泛型
// 1)全部保留
class Son3<T1, T2, A, B> extends Father<T1, T2> {}
// 2)部分保留
class Son4<T2, A, B> extends Father<Integer, T2> {}
```

​	如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。

​	静态方法、在try-catch中不能使用类的泛型，异常类不能是泛型的。

实例化

```Java
List<String> strList = new ArrayList<String>();
Iterator<Customer> iterator = customers.iterator();
```

​	一定要在类名后面指定类型参数的值(类型)。

​	泛型不同的引用不能相互赋值。

​	实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。

​	泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。

​	不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity];

示例

```java
class Person<T> {
// 使用T类型定义变量
private T info;
// 使用T类型定义一般方法
public T getInfo() {
	return info;
}
public void setInfo(T info) {
	this.info = info;
}
// 使用T类型定义构造器
public Person() {
}
public Person(T info) {
	this.info = info;
}
```

### 泛型方法

不管类是不是泛型类，都可以定义泛型方法。

在泛型方法中可以定义泛型参数

格式： [访问权限] <泛型> 返回类型 方法名([泛型标识 参数名称]) 抛出的异常

```Java
public class DAO {
	public <E> E get(int id, E e) {
		E result = null;
		return result;
	}
}
```

## 泛型在继承上的体现

类A是类B的父类，但是G<A> 和G<B>二者不具备子父类关系，A<G> 是 B<G> 的父类。

## 通配符的使用

```Java
List<Object> list1 = null;
List<String> list2 = null;
List<?> list = null;
//这样不可：list1 = list2
list = list1;
list = list2;
```

有限制条件的通配符的使用

```java
< ? extends A >
	G<? extends A> 可以作为G<A>和G<B>的父类，其中B是A的子类
<? super A>
	G<? super A> 可以作为G<A>和G<B>的父类，其中B是A的父类
```

//这里讲的稀烂还是我听得不行？20220216 0942

# 0X07、IO流

## File类的使用

File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)
File类声明在java.io包下。
File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。
后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的"终点"。

实例化

```Java
File(String filePath)
File(String parentPath,String childPath)
File(File parentFile,String childPath)
```

相对路径：相较于某个路径下，指明的路径。
绝对路径：包含盘符在内的文件或文件目录的路径

路径分隔符：windows:\\，unix:/
public static final String separator。根据操作系统，动态的提供分隔符。

一些方法

```java
public String getAbsolutePath()：获取绝对路径
public String getPath() ：获取路径
public String getName() ：获取名称
public String getParent()：获取上层文件目录路径。若无，返回null
public long length() ：获取文件长度(即：字节数)。不能获取目录的长度。
public long lastModified() ：获取最后一次的修改时间，毫秒值
//如下的两个方法适用于文件目录：
public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组
public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组
    
public boolean renameTo(File dest):把文件重命名为指定的文件路径.
//要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。
    
public boolean isDirectory()：判断是否是文件目录
public boolean isFile() ：判断是否是文件
public boolean exists() ：判断是否存在
public boolean canRead() ：判断是否可读
public boolean canWrite() ：判断是否可写
public boolean isHidden() ：判断是否隐藏
    
//创建硬盘中对应的文件或文件目录
public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false
public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。
public boolean mkdirs() ：创建文件目录。如果此文件目录存在，就不创建了。如果上层文件目录不存在，一并创建

//删除磁盘中的文件或文件目录
public boolean delete()：删除文件或者文件夹
//删除注意事项：Java中的删除不走回收站。
```

## IO流原理及流的分类

I/O是Input/Output的缩写。处理数据传输。如读/写文件，网络通讯等。

Java程序中，对于数据的输入/输出操作以“流(stream)” 的方式进行。

输入input：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中。

输出output：将程序(内存) 数据输出到磁盘、光盘等存储设备中。

### 流的分类

按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)
按数据流的流向不同分为：输入流，输出流
按流的角色的不同分为：节点流，处理流

Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。
由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。
| (抽象基类) | 字节流       | 字符流 |
| ---------- | ------------ | ------ |
| 输入流     | InputStream  | Reader |
| 输出流     | OutputStream | Writer |

### 节点流和处理流

节点流：直接从数据源或目的地读写数据

处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流(节点流或处理流)之上，通过对数据的处理为程序提供更为强大的读写功能。

### InputStream & Reader

InputStream 和 Reader 是所有输入流的基类。

```java
InputStream(典型实现：FileInputStream)
    int read()	//从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回值-1。
    int read(byte[] b)	//从此输入流中将最多b.length个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值-1。否则以整数形式返回实际读取的字节数。
    int read(byte[] b, int off, int len)	//将输入流中最多len个数据字节读入byte数组。尝试读取len个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值-1。
Reader(典型实现：FileReader)
    int read()	//读取单个字符。作为整数读取的字符，范围在0到65535之间 (0x00-0xffff)(2个字节的Unicode码)，如果已到达流的末尾，则返回-1
    int read(char [] c)	//将字符读入数组。如果已到达流的末尾，则返回-1。否则返回本次读取的字符数。
    int read(char [] c, int off, int len)	//将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回-1。否则返回本次读取的字符数。

public void close() throws IOException	//关闭此输入流并释放与该流关联的所有系统资源。
```

​	程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件 IO 资源。
​	FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream用于读取非文本数据之类的原始字节流。要读取字符流，需要使用FileReader

### OutputStream & Writer

```java
void write(int b)OutputStream	//将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数b 的八个低位。b的24个高位将被忽略。 即写入0~255范围的。
void write(byte[] b)	//将b.length个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是：应该与调用write(b, 0, b.length)的效果完全相同。
void write(byte[] b,int off,int len)	//将指定byte数组中从偏移量off开始的len个字节写入此输出流。
public void flush()throws IOException	//刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。
public void close() throws IOException	//关闭此输出流并释放与该流关联的所有系统资源。
    
void write(int c) //写入单个字符。要写入的字符包含在给定整数值的16个低位中，16高位被忽略。 即写入0到65535之间的Unicode码。
void write(char[] cbuf)	//写入字符数组。
void write(char[] cbuf,int off,int len)	//写入字符数组的某一部分。从off开始，写入len个字符
void write(String str)	//写入字符串。
void write(String str,int off,int len)	//写入字符串的某一部分。
void flush()	//刷新该流的缓冲，则立即将它们写入预期目标。
public void close() throws IOException	//关闭此输出流并释放与该流关联的所有系统资源。
```

因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组， 即以 String 对象作为参数

### IO流体系

![image-20220216141554937](./assets/java/image-20220216141554937.png)

## 节点流(或文件流) 

| 抽象基类|节点流(或文件流)|缓冲流(处理流的一种)|
| ------------------------------------------------------------ | ------------------ | ---------------------- |
| InputStream|FileInputStream   (read(byte[] buffer))|BufferedInputStream (read(byte[] buffer))|
| OutputStream | FileOutputStream  (write(byte[] buffer,0,len) | BufferedOutputStream (write(byte[] buffer,0,len) / flush() |
| Reader | FileReader (read(char[] cbuf)) | BufferedReader (read(char[] cbuf) / readLine()) |
| Writer | FileWriter (write(char[] cbuf,0,len) | BufferedWriter (write(char[] cbuf,0,len) / flush() |

实现文本文件的拷贝

```Java
FileReader fr = null;
FileWriter fw = null;
try {
    //1.创建File类的对象，指明读入和写出的文件
    File srcFile = new File("hello.txt");
    File destFile = new File("hello3.txt");
    //不能使用字符流来处理图片等字节数据

    //2.创建输入流和输出流的对象
    fr = new FileReader(srcFile);
    fw = new FileWriter(destFile);

    //3.数据的读入和写出操作
    char[] cbuf = new char[5];
    int len;//记录每次读入到cbuf数组中的字符的个数
    while ((len = fr.read(cbuf)) != -1) {
        //每次写出len个字符
        fw.write(cbuf, 0, len);
    }
    fw.write("\n拷贝成功！");
} catch (IOException e) {
    e.printStackTrace();
} finally {
    //4.关闭流资源
    try {
        if (fw != null)
            fw.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
    try {
        if (fr != null)
            fr.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

非文本文件的拷贝

```Java
FileInputStream fis = null;
FileOutputStream fos = null;
try {
	//造文件
	File srcFile = new File(srcPath);
	File destFile = new File(destPath);

	//造流
	fis = new FileInputStream(srcFile);
	fos = new FileOutputStream(destFile);

	//复制的过程
	byte[] buffer = new byte[1024];
	int len;
	while((len = fis.read(buffer)) != -1){
		fos.write(buffer,0,len);
	}

} catch (IOException e) {
	e.printStackTrace();
} finally {
	//关闭资源
	if(fos != null){
		try {
			fos.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	if(fis != null){
		try {
			fis.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
```

## 缓冲流

缓冲流为处理流的一种。【类型见上表格】

处理流：就是“套接”在已有的流的基础上。

缓冲流的作用：提高流的读取、写入速度，原因：内部提供了一个缓冲区。
![image-20220217110341831](./assets/java/image-20220217110341831.png)

```Java
BufferedInputStream bis = null;
BufferedOutputStream bos = null;

File srcFile = new File(srcPath);
File destFile = new File(destPath);

try {
    FileInputStream fis = new FileInputStream(srcFile);
    FileOutputStream fos = new FileOutputStream(destFile);

    bis = new BufferedInputStream(fis);
    bos = new BufferedOutputStream(fos);

    byte buffer[] = new byte[1024];
    int len;
    while((len = bis.read(buffer))!=-1){
        bos.write(buffer,0,len);
    }
} catch (IOException e) {
    e.printStackTrace();
}finally {
    //关闭资源
    //要求：先关闭外层的流，再关闭内层的流
    if(bos != null){
        try {
            bos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    if(bis != null){
        try {
            bis.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.
}
```

## 转换流

提供了在字节流和字符流之间的转换。

	InputStreamReader：将一个字节的输入流转换为字符的输入流	//解码：字节、字节数组  --->字符数组、字符串
	OutputStreamWriter：将一个字符的输出流转换为字节的输出流	//编码：字符数组、字符串 ---> 字节、字节数组

字节流中的数据都是字符时，转成字符流操作更高效。

使用转换流来处理文件乱码问题，实现编码和解码的功能。

![image-20220217110558985](./assets/java/image-20220217110558985.png)



【字符集】
ASCII：美国标准信息交换码。用一个字节的7位可以表示。
ISO8859-1：拉丁码表。欧洲码表。用一个字节的8位表示。
GB2312：中国的中文编码表。最多两个字节编码所有字符
GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码
UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。

Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。
Unicode设计存在问题：怎么知道是两个还是一个字节表示一个字符，用高位区分的话则可表示数量就不满足了。
Unicode字符集只是定义了字符的集合和 唯一编号，而具体的编码实现并没有。UTF-8、 UCS-2/UTF-16是具体的编码方案。

字符编码
![image-20220217124220332](./assets/java/image-20220217124220332.png)

## 标准输入、输出流

System.in和System.out
​	分别代表了系统标准的输入和输出设备
​	System.in:标准的输入流，默认从键盘输入，类型是InputStream。
​	System.out:标准的输出流，默认从控制台输出，类型是PrintStream。
​	System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入和输出的流。

```Java
InputStreamReader isr = new InputStreamReader(System.in);
br = new BufferedReader(isr);
System.out.println("请输入字符串：");
String data = br.readLine();
```

## 打印流

PrintStream 和 PrintWriter
	提供了一系列重载的print() 和 println()，用于多种数据类型的输出
​	PrintStream和PrintWriter的输出不会抛出IOException异常
​	PrintStream和PrintWriter有自动flush功能
​	PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。
​	System.out返回的是PrintStream的实例

```Java
PrintStream ps = null;
try {
    FileOutputStream fos = new FileOutputStream(new File("hello.txt"));
    // 创建打印输出流,设置为自动刷新模式(写入换行符或字节 '\n' 时都会刷新输出缓冲区)
    ps = new PrintStream(fos, true);
    if (ps != null) {// 把标准输出流(控制台输出)改成文件
        System.setOut(ps);
    }
    for (int i = 0; i <= 255; i++) { // 输出ASCII字符
        System.out.print((char) i);
        if (i % 50 == 0) { // 每50个数据一行
            System.out.println(); // 换行
        }
    }
} catch (FileNotFoundException e) {
    e.printStackTrace();
} finally {
    if (ps != null) {
        ps.close();
    }
}
```

## 数据流

DataInputStream 和 DataOutputStream
	用于读取或写出基本数据类型的变量或字符串
​	分别“套接”在 InputStream 和 OutputStream 子类的流上
​	DataInputStream中的方法

```Java
boolean readBoolean() byte readByte()
char readChar() float readFloat()
double readDouble() short readShort()
long readLong() int readInt()
String readUTF() void readFully(byte[] b)
//DataOutputStream中的方法：将上述的方法的read改为相应的write即可。
```

将基本数据类型变量和字符串从内存存储到文件中

```Java
DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.txt"));
dos.writeUTF("filwsx");
dos.writeInt(35);
dos.writeBoolean(true);
dos.flush();//刷新操作，将内存中的数据写入文件
dos.close();
```

将文件中存储的基本数据类型变量和字符串读取到内存中。

```Java
DataInputStream dis = new DataInputStream(new FileInputStream("data.txt"));
String name = dis.readUTF();
int age = dis.readInt();
boolean isMale = dis.readBoolean();
dis.close();
```

## 对象流

​	用于存储和读取基本数据类型数据或对象的处理流。
​	它的强大之处就是可 以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。
​	序列化：用ObjectOutputStream类保存基本类型数据或对象的机制
​	反序列化：用ObjectInputStream类读取基本类型数据或对象的机制
​	ObjectOutputStream和ObjectInputStream不能序列化static和transient修 饰的成员变量

```
若某个类实现了 Serializable 接口，该类的对象就是可序列化的：
	创建一个ObjectOutputStream
	调用ObjectOutputStream对象的writeObject(对象)方法输出可序列化对象
	注意写出一次，操作flush()一次
反序列化
	创建一个 ObjectInputStream
	调用 readObject() 方法读取流中的对象
强调：如果某个类的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field 的类也不能序列化
```

【对象的序列化】
​	对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而持久地把对象保存在磁盘上，或传输到另一个网络。
​	如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的。
​	为了让某个类是可序列化的，该类必须实现Serializable、Externalizable两个接口之一。否则会抛出NotSerializableException异常。

## 随机存取文件流

RandomAccessFile 类

```
RandomAccessFile声明在java.io包下，但直接继承于java.lang.Object类。
它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写。
RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件
	支持只访问文件的部分内容
	可以向已存在的文件后追加内容
RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。
RandomAccessFile 类对象可以自由移动记录指针：
	long getFilePointer()：获取文件记录指针的当前位置
	void seek(long pos)：将文件记录指针定位到pos位置
构造器
	public RandomAccessFile(File file, String mode)
	public RandomAccessFile(String name, String mode)
创建RandomAccessFile类实例需要指定一个mode参数，该参数指定RandomAccessFile的访问模式：
	r: 以只读方式打开
	rw：打开以便读取和写入
	rwd:打开以便读取和写入；同步文件内容的更新
	rws:打开以便读取和写入；同步文件内容和元数据的更新
如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。
如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建。
```

可以用RandomAccessFile这个类，来实现一个多线程断点下载的功能。

如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。

如果写出到的文件存在，则会对原有文件内容进行覆盖。(默认情况下，从头覆盖)

可以通过相关的操作，实现RandomAccessFile“插入”数据的效果

## NIO.2

Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。
NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。
NIO将以更加高效的方式进行文件的读写操作。

Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网 络编程NIO。
```Java
|-----java.nio.channels.Channel
	|-----FileChannel:处理本地文件
	|-----SocketChannel：TCP网络编程的客户端的Channel
	|-----ServerSocketChannel:TCP网络编程的服务器端的Channel
	|-----DatagramChannel：UDP网络编程中发送端和接收端的Channel
```

随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。
	NIO.2在java.nio.file包下还提供了Files、Paths工具类
​	Files包含 了大量静态的工具方法来操作文件。
​	Paths则包含了两个返回Path的静态工厂方法。

## Path、Paths、Files类

```Java
Paths类提供的静态get()方法用来获取Path对象：
	static Path get(String first, String … more) : 用于将多个字符串串连成路径
	static Path get(URI uri): 返回指定uri对应的Path路径
```

Path接口

```Java
String toString() ： 返回调用Path对象的字符串表示形式
boolean startsWith(String path) : 判断是否以path路径开始
boolean endsWith(String path) : 判断是否以path路径结束
boolean isAbsolute() : 判断是否是绝对路径
Path getParent() ：返回Path对象包含整个路径，不包含Path对象指定的文件路径
Path getRoot() ：返回调用Path对象的根路径
Path getFileName() : 返回与调用Path对象关联的文件名
int getNameCount() : 返回Path 根目录后面元素的数量
Path getName(int idx) : 返回指定索引位置idx的路径名称
Path toAbsolutePath() : 作为绝对路径返回调用Path对象
Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象
File toFile(): 将Path转化为File类的对象
```

Files 类

```java
//java.nio.file.Files 用于操作文件或目录的工具类。
//常用方法：
	Path copy(Path src, Path dest, CopyOption … how) : 文件的复制
	Path createDirectory(Path path, FileAttribute<?> … attr) : 创建一个目录
	Path createFile(Path path, FileAttribute<?> … arr) : 创建一个文件
	void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错
	void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除
	Path move(Path src, Path dest, CopyOption…how) : 将src移动到dest位置
	long size(Path path) : 返回 path 指定文件的大小
//用于判断
	boolean exists(Path path, LinkOption … opts) : 判断文件是否存在
	boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录
	boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件
	boolean isHidden(Path path) : 判断是否是隐藏文件
	boolean isReadable(Path path) : 判断文件是否可读
	boolean isWritable(Path path) : 判断文件是否可写
	boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在
//用于操作内容
	SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how指定打开方式。
	DirectoryStream<Path> newDirectoryStream(Path path) : 打开path指定的目录
	InputStream newInputStream(Path path, OpenOption…how):获取InputStream对象
	OutputStream newOutputStream(Path path, OpenOption…how) : 获取OutputStream对象
```

## 小结

```
流是用来处理数据的。
处理数据时，一定要先明确数据源，与数据目的地
	数据源可以是文件，可以是键盘。
	数据目的地可以是文件、显示器或者其他设备。
而流只是在帮助数据进行传输,并对传输的数据进行处理，比如过滤处理、转换处理等。
```

# 0X08、网络编程

## Java网络类库

Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在Java的本机安装系统里，由 JVM 进行控制。

Java实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境。

## 网络基础

这里我有基础了，跳过！

网络编程的目的：直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。
网络编程中有两个主要的问题：

```
问题一：如何准确地定位网络上一台或多台主机；定位主机上的特定的应用
问题二：找到主机后如何可靠高效地进行数据传输
```

如何实现网络中的主机互相通信

```
通信双方地址：IP、端口号	【解决问题一】
一定的规则(即：网络通信协议。有两套参考模型)【解决问题二】
	OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广。
	TCP/IP参考模型(或TCP/IP协议)：事实上的国际标准。
```

网络通信协议

![image-20220217182326832](./assets/java/image-20220217182326832.png)

IP地址：InetAddress

```
唯一的标识 Internet 上的计算机(通信实体)
本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost
IP地址分类方式1：IPV4 和 IPV6
	IPV4：4字节，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。以点分十进制表示，如192.168.0.1
	IPV6：128位，写成8个四位十六进制位整数，数之间用冒号:分开，如3ffe:3201:1401:1280:c8ff:fe4d:db39:1984
IP地址分类方式2：
	公网地址(万维网使用)和私有地址(局域网使用)。
	192.168.开头的就是私有址址，范围即为192.168.0.0--192.168.255.255，专门为组织机构内部使用
特点：不易记忆【域名解析服务解决这个问题】
```

端口号标识正在计算机上运行的进程

```
不同的进程有不同的端口号
被规定为一个16位的整数0~65535。
端口分类：
	公认端口：0~1023。被预先定义的服务通信占用(如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23)
	注册端口：1024~49151。分配给用户进程或应用程序。(如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等)。
	动态/私有端口：49152~65535。
```

端口号与IP地址的组合得出一个网络套接字：Socket。

## 协议簇

### TCP协议

```
使用TCP协议前，须先建立TCP连接，形成传输数据通道
传输前，采用“三次握手”方式，点对点通信，是可靠的
TCP协议进行通信的两个应用进程：客户端、服务端。
在连接中可进行大数据量的传输
传输完毕，需释放已建立的连接，效率低
```

### UDP协议

```
将数据、源、目的封装成数据包，不需要建立连接
每个数据报的大小限制在64K内
发送不管对方是否准备好，接收方收到也不确认，故是不可靠的
可以广播发送
发送数据结束时无需释放资源，开销小，速度快。
```

TCP三次握手、四次握手

### Socket

利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。
网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。
通信的两端都要有Socket，是两台机器间通信的端点。
网络通信其实就是Socket间的通信。
Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。
一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。

Socket分类：
```Java
流套接字(stream socket)：使用TCP提供可依赖的字节流服务
数据报套接字(datagram socket)：使用UDP提供“尽力而为”的数据报服务
```

Socket类的常用构造器：
```Java
public Socket(InetAddress address,int port)创建一个流套接字并将其连接到指定 IP 地址的指定端口号。
public Socket(String host,int port)创建一个流套接字并将其连接到指定主机上的指定端口号。
```

Socket类的常用方法：
```Java
public InputStream getInputStream()返回此套接字的输入流。可以用于接收网络消息
public OutputStream getOutputStream()返回此套接字的输出流。可以用于发送网络消息
public InetAddress getInetAddress()此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回null。
public InetAddress getLocalAddress()获取套接字绑定的本地地址。即本端的IP地址
public int getPort()此套接字连接到的远程端口号；如果尚未连接套接字，则返回0。
public int getLocalPort()返回此套接字绑定到的本地端口。如果尚未绑定套接字，则返回 -1。即本端的端口号。
public void close()关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用(即无法重新连接或重新绑定)。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的InputStream和OutputStream。
public void shutdownInput()如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回EOF(文件结束符)。即不能在从此套接字的输入流中接收任何数据。
public void shutdownOutput()禁用此套接字的输出流。对于TCP套接字，任何以前写入的数据都将被发送，并且后跟TCP的正常连接终止序列。如果在套接字上调用shutdownOutput()后写入套接字输出流，则该流将抛出IOException。即不能通过此套接字的输出流发送任何数据。
```

## InetAdress类

```
InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取
InetAddress实例
	public static InetAddress getLocalHost()
	public static InetAddress getByName(String host)
InetAddress提供了如下几个常用的方法
	public String getHostAddress()：返回IP地址字符串(以文本表现形式)。
	public String getHostName()：获取此IP地址的主机名。
	public boolean isReachable(int timeout)：测试是否可以达到该地址。
```

## TCP网络编程

### 概述

基于TCP的Socket通信

![image-20220217190311924](./assets/java/image-20220217190311924.png)

客户端Socket的工作过程

```
创建Socket：
	根据指定服务端的IP地址或端口号构造Socket类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。
打开连接到 Socket 的输入/出流：
	使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输
按照一定的协议对 Socket 进行读/写操作：
	通过输入流读取服务器放入线路的信息(但不能读取自己放入线路的信息)，通过输出流将信息写入线程。
关闭Socket：
	断开客户端到服务器的连接，释放线路
```

服务器程序的工作过程

```
调用 ServerSocket(int port) ：
	创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。
调用 accept()：
	监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。
调用 该Socket类对象的getOutputStream()和getInputStream ()：
	获取输出流和输入流，开始网络数据的发送和接收。
关闭ServerSocket和Socket对象：
	客户端访问结束，关闭通信套接字。
```

实际案例

![image-20220217231302488](./assets/java/image-20220217231302488.png)

## UDP网络编程

### 概述

类DatagramSocket和DatagramPacket实现了基于UDP协议网络程序。
UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证。
UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。
DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。
UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。

### DatagramSocket

```Java
public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP地址由内核来选择。
public DatagramSocket(int port,InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在0到65535之间(包括两者)。如果IP地址为 0.0.0.0，套接字将被绑定到通配符地址，IP地址由内核选择。
public void close()关闭此数据报套接字。
public void send(DatagramPacket p)从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的IP地址和远程主机的端口号。
public void receive(DatagramPacket p)从此套接字接收数据报包。当此方法返回时，DatagramPacket的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。
public InetAddress getLocalAddress()获取套接字绑定的本地地址。
public int getLocalPort()返回此套接字绑定的本地主机上的端口号。
public InetAddress getInetAddress()返回此套接字连接的地址。如果套接字未连接，则返回null。
public int getPort()返回此套接字的端口。如果套接字未连接，则返回 -1。
public DatagramPacket(byte[] buf,int length)构造 DatagramPacket，用来接收长度为 length 的数据包。length参数必须小于等于buf.length。
public DatagramPacket(byte[] buf,int length,InetAddress address,int port)构造数据报包，用来将长度为length的包发送到指定主机上的指定端口号。length参数必须小于等于buf.length。
public InetAddress getAddress()返回某台机器的IP地址，此数据报将要发往该机器或者是从该机器接收到的。
public int getPort()返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。
public byte[] getData()返回数据缓冲区。接收到的或将要发送的数据从缓冲区中的偏移量 offset 处开始，持续length长度。
public int getLength()返回将要发送或接收到的数据的长度。
```

### UDP网络通信

```
流程：
	1.DatagramSocket与DatagramPacket
	2.建立发送端，接收端
	3.建立数据包
	4.调用Socket的发送、接收方法
	5.关闭Socket
发送端与接收端是两个独立的运行程序
```

## URL编程

URL:(Uniform Resource Locator) 统一资源定位符，对应着互联网的某一资源地址

格式：http://localhost:8080/examples/beauty.jpg?username=Tom

​			协议   主机名    端口号  资源地址           参数列表

```java
public String getProtocol( ) 获取该URL的协议名
public String getHost( ) 获取该URL的主机名
public String getPort( ) 获取该URL的端口号
public String getPath( ) 获取该URL的文件路径
public String getFile( ) 获取该URL的文件名
public String getQuery( ) 获取该URL的查询名
```

## 小结

略。

# *0X09、Java反射机制

## 概述

反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。

加载完类后，在堆内存的方法区中就产生了一个Class类型的对象(一个类只有一个Class对象)，该对象包含了完整的类的结构信息。

动态语言 vs 静态语言：运行是是否可以改变其代码结构

Java反射机制提供的功能

```
在运行时判断任意一个对象所属的类
在运行时构造任意一个类的对象
在运行时判断任意一个类所具有的成员变量和方法
在运行时获取泛型信息
在运行时调用任意一个对象的成员变量和方法
在运行时处理注解
生成动态代理
```

反射相关的主要API

```
java.lang.Class:代表一个类
java.lang.reflect.Method:代表类的方法
java.lang.reflect.Field:代表类的成员变量
java.lang.reflect.Constructor:代表类的构造器
```

## Class类

在Object类中定义了以下的方法，此方法将被所有子类继承： public final Class getClass()

```
Class本身也是一个类
Class 对象只能由系统建立对象
一个加载的类在 JVM 中只会有一个Class实例
一个Class对象对应的是一个加载到JVM中的一个.class文件
每个类的实例都会记得自己是由哪个 Class 实例所生成
通过Class可以完整地得到一个类中的所有被加载的结构
Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象
一个 Class对象包含了特定某个结构(class/interface/enum/annotation/primitive type/void/[])的有关信息
```

Class类的常用方法

```Java
static Class forName(String name) 返回指定类名name的Class对象
Object newInstance() 调用缺省构造函数，返回该Class对象的一个实例
getName() 返回此Class对象所表示的实体(类、接口、数组类、基本类型或void)名称
Class getSuperClass() 返回当前Class对象的父类的Class对象
Class [] getInterfaces() 获取当前Class对象的接口
ClassLoader getClassLoader() 返回该类的类加载器
Class getSuperclass() 返回表示此Class所表示的实体的超类的Class
Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组
Field[] getDeclaredFields() 返回Field对象的一个数组
Method getMethod(String name,Class … paramTypes) 返回一个Method对象，此对象的形参类型为paramType
```

问题导向

```
疑问1：通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用那个？
	建议：直接new的方式。
	什么时候会使用：反射的方式。 反射的特征：动态性
疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？
	不矛盾。
```

关于java.lang.Class类的理解

    1.类的加载过程：
    	程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。
    	接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。
    2.换句话说，Class的实例就对应着一个运行时类。
    3.加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。

## *获取Class实例

四种方法

```Java
方法一：
	前提：若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高
	实例：Class cla1 = Person.class;
方法二：
	前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象
	实例：Person p1 = new Person("Jerry",3);
         Class cla2 = p1.getClass();
方法三：
	前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException
	实例：Class cla3 = Class.forName("com.filwsx.JavaStudyAdvanced.Annotation.Person");
方法四：
	ClassLoader classLoader = ReflectionTest.class.getClassLoader();
    Class cla4 = classLoader.loadClass("com.filwsx.JavaStudyAdvanced.Annotation.Person");
```

哪些类型可以有Class对象

```
(1)class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类
(2)interface：接口   (3)[]：数组   (4)enum：枚举  (5)annotation：注解@interface
(6)primitive type：基本数据类型  (7)void
```

只要数组的元素类型与维度一样，就是同一个Class

## 类的加载

当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过 如下三个步骤来对该类进行初始化。

![image-20220218131755956](./assets/java/image-20220218131755956.png)

加载

```
将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与。
```

链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。

```
验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题
准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。
解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。
```

初始化：

```
	执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。(类构造器是构造类信息的，不是构造该类对象的构造器)。
	当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
	虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。
```

什么时候会发生类初始化

```
类的主动引用(一定会发生类的初始化)
	当虚拟机启动，先初始化main方法所在的类
	new一个类的对象
	调用类的静态成员(除了final常量)和静态方法
	使用java.lang.reflect包的方法对类进行反射调用
	当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类
类的被动引用(不会发生类的初始化)
	当访问一个静态域时，只有真正声明这个域的类才会被初始化
		当通过子类引用父类的静态变量，不会导致子类初始化
	通过数组定义类引用，不会触发此类的初始化
	引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了)
```

## ClassLoader

类加载器作用是用来把类(class)装载进内存的。

JVM 规范定义了如下类型的 类的加载器。

![image-20220218141256544](./assets/java/image-20220218141256544.png)

```Java
//对于自定义类，使用系统类加载器进行加载
ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
//调用系统类加载器的getParent()：获取扩展类加载器
ClassLoader classLoader1 = classLoader.getParent();
//调用扩展类加载器的getParent()：无法获取引导类加载器
//引导类加载器主要负责加载java的核心类库，无法加载自定义类的。
ClassLoader classLoader2 = classLoader1.getParent();
//测试当前类由哪个类加载器进行加载
ClassLoader classLoader3 = String.class.getClassLoader();
```

## *创建运行时类的对象

方法一：调用Class对象的newInstance()方法

要想此方法正常的创建运行时类的对象，要求：

```
1.运行时类必须提供空参的构造器。【没有无参的构造器，要在操作时明确调用类的构造器，并将参数传递进去】
2.空参的构造器的访问权限得够。通常，设置为public。【private也可，使用getDeclaredConstructor()】
```

在javabean中要求提供一个public的空参构造器。原因：

```
1.便于通过反射，创建运行时类的对象
2.便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器
```

实例代码

```Java
Class<Person> clss = Person.class;
Person p1 = clss.newInstance();
System.out.println(p1);
```

## 获取运行时类的完整结构

结构：Field、Method、Constructor、Superclass、Interface、Annotation

1.实现的全部接口
```
public Class<?>[] getInterfaces()	//确定此对象所表示的类或接口实现的接口。
```

2.所继承的父类
```Java
public Class<? Super T> getSuperclass()	//返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的Class。
```

3.全部的构造器
```Java
public Constructor<T>[] getConstructors()	//返回此 Class 对象所表示的类的所有public构造方法。
public Constructor<T>[] getDeclaredConstructors()	//返回此 Class 对象表示的类声明的所有构造方法。
Constructor类中：
	取得修饰符: public int getModifiers();
	取得方法名称: public String getName();
	取得参数的类型：public Class<?>[] getParameterTypes();
```

4.全部的方法
```Java
public Method[] getDeclaredMethods()	//返回此Class对象所表示的类或接口的全部方法
public Method[] getMethods()	//返回此Class对象所表示的类或接口的public的方法
Method类中：
	public Class<?> getReturnType()取得全部的返回值
	public Class<?>[] getParameterTypes()取得全部的参数
	public int getModifiers()取得修饰符
	public Class<?>[] getExceptionTypes()取得异常信息
```

5.全部的Field
```Java
public Field[] getFields()	//返回此Class对象所表示的类或接口的public的Field。【包含父类中public属性】
public Field[] getDeclaredFields()	//返回此Class对象所表示的类或接口的全部Field。【不包含父类中声明的属性】
Field方法中：
	public int getModifiers() 以整数形式返回此Field的修饰符
	public Class<?> getType() 得到Field的属性类型
	public String getName() 返回Field的名称。
```

6.Annotation相关
```Java
get Annotation(Class<T> annotationClass)
getDeclaredAnnotations()
```

7.泛型相关
```Java
获取父类泛型类型：Type getGenericSuperclass()
泛型类型：ParameterizedType
获取实际的泛型类型参数数组：getActualTypeArguments()
```

8.类所在的包
```Java
Package getPackage() 
```


## *调用运行时类的指定结构

### 调用指定方法

通过反射，调用类中的方法，通过Method类完成。

```
1.通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。
2.之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。
```

Object invoke(Object obj, Object … args)
	1.Object 对应原方法的返回值，若原方法无返回值，此时返回null
	2.若原方法若为静态方法，此时形参Object obj可为null
	3.若原方法形参列表为空，则Object[] args为null
	4.若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。

### 调用指定属性

在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。
	public Field getField(String name) 返回此Class对象表示的类或接口的指定的public的Field。
	public Field getDeclaredField(String name)返回此Class对象表示的类或接口的指定的Field。

在Field中：
	public Object get(Object obj) 取得指定对象obj上此Field的属性内容
	public void set(Object obj,Object value) 设置指定对象obj上此Field的属性内容

### setAccessible()

Method和Field、Constructor对象都有setAccessible()方法。

setAccessible启动和禁用访问安全检查的开关。

参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。
	提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。
	使得原本无法访问的私有成员也可以访问

参数值为false则指示反射的对象应该实施Java语言访问检查。

## 动态代理

### 代理设计模式原理

```
使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。
任何对原始对象的调用都要通过代理。
代理对象决定是否以及何时将方法调用转到原始对象上。
```

### 静态代理

```
特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。
每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。
最好可以通过一个代理类完成全部的代理功能。
```

### 动态代理

```
概念
	指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。
使用场合
	调试、远程方法调用
相比于静态代理的优点
	抽象角色中(接口)声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。
```

**要想实现动态代理，需要解决的问题？**
	问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。
	问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。

### 动态代理相关API

Proxy ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。

提供用于创建动态代理类和动态代理对象的静态方法

```
static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces) 创建一个动态代理类所对应的Class对象
static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h) 直接创建一个动态代理对象
```

动态代理步骤

```
1.创建一个实现接口InvocationHandler的类，它必须实现invoke方法，以完成代理的具体操作。
2.创建被代理的类以及接口
3.通过Proxy的静态方法
4.通过Subject代理调用RealSubject实现类的方法
```

动态代理与AOP（Aspect Orient Programming)

​	略。代理这种设计模式存在的价值我都无法体会！

​	动态代理这部分马马虎虎跟着敲完了代码，就先这样吧！

# END

学习的思维方式：
1. "大处着眼，小处着手"

2. 逆向思维、反证法  List<String> list2; List<Object> list1 = list2;

3. 透过问题看本质


两句话：
1. 小不忍则乱大谋

2. 识时务者为俊杰

# 0X10、Java新特性

## Java8

### 简介

![image-20220219190549865](./assets/java/image-20220219190549865.png)

```
速度更快、代码更少(增加了新的语法：Lambda 表达式)、强大的 Stream API、便于并行
最大化减少空指针异常：Optional、Nashorn引擎，允许在JVM上运行JS应用
```

### Lambda表达式

概念：对函数式接口实例化，并通过简洁的方式表达，同时这段代码可作为实参传递(c语言中的函数指针)【简洁的意思就是：能省就省】（按照这个定义，Comparator并不是函数式接口，但可以用lambda！！！）

函数式接口：如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。

用匿名实现类的现在都可以用Lambda表达式来写。

格式
-> :lambda操作符 或 箭头操作符
->左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）
->右边：lambda体 （其实就是重写的抽象方法的方法体）

Lambda表达式的使用总结：（分为6种情况介绍）【能省就省的原则体现】
->左边：lambda形参列表的参数类型可以省略(类型推断，只有一个)；如果lambda形参列表只有一个参数，()可以省略
​		没有参数为()，一个参数省括号，多个参数不能省。类型声明可以省-编译器可以做出类型推断
->右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字
​		一条语句：省{}，有返回值省return。多条语句不能省。

### 函数式接口

在java.util.function包下定义了Java8丰富的函数式接口。

Lambda表达式是对象，而不是函数，它们必须依附于一类特别的 对象类型——函数式接口。

使得java不但可以支持OOP，还可以支持OOF（面向函数编程）

java内置4大核心函数式接口
​	消费型接口 Consumer<T>     void accept(T t)	
​	供给型接口 Supplier<T>     T get()
​	函数型接口 Function<T,R>   R apply(T t)
​	断定型接口 Predicate<T>    boolean test(T t)

自定义函数式接口

略。

### 方法引用

当Lambda表达式要做的操作已经有方法实现，可以把这个方法传递给Lambda【这不就是c的函数指针嘛！】

 情况1、对象 :: 实例方法【使用操作符 “::” 将类(或对象) 与方法名分隔开来。】

```Java
// 要求：实现接口的抽象方法的参数列表和返回值类型，与方法引用的保持一致！
// Consumer中的void accept(T t) 与 PrintStream中的void println(T t)
@Test
public void test1() {
    //原本的实现方式
	Consumer<String> con1 = str -> System.out.println(str);
	con1.accept("北京");
    //使用方法引用
	Consumer<String> con2 = (System.out)::println;
	con2.accept("beijing");
}
```

情况2、类::静态方法名

```Java
// 要求：实现接口的抽象方法的参数列表和返回值类型，与方法引用的保持一致！
//Comparator中的int compare(T t1,T t2) 与 Integer中的int compare(T t1,T t2)
//Function中的R apply(T t) 与 Math中的Long round(Double d)
Comparator<Integer> con1 = (t1,t2) -> Integer.compare(t1,t2);
System.out.println(con1.compare(12, 34));
Comparator<Integer> con2 = Integer::compare;
System.out.println(con2.compare(89, 64));
System.out.println("*******************");
Function<Double,Long> con3 = d -> Math.round(d);
System.out.println(con3.apply(1.4));
Function<Double,Long> con4 = Math::round;
System.out.println(con4.apply(2.9));
```

情况3、类::实例方法名

此种情况简单总结：左侧为<参数1，参数2> 。"参数1与参数2"  可写成 "参数1.参数2" 那么右侧可用符合 "参数1.参数2"的函数，即可允许参数变引用对象，**个数和类型应该要一致，至于位置不要求**！【这么说的话，编译器得多复杂！】

```Java
// Comparator中的int comapre(T t1,T t2) 与 String中的int t1.compareTo(t2)
// Function中的R apply(T t) 与 Person中的String getName();
Comparator<String> con1 = String :: compareTo;
Function<Person,String> con2 = Person :: getName;
System.out.println(con2.apply(new Person("Tom", 13)));
System.out.println(con1.compare("abc", "abd"));
```

注：lambda与方法引用，需要对常用函数特别熟悉，多写才行！

### 构造器引用

把构造器引用赋值给定义的方法

格式： ClassName::new 

要求：①构造器参数列表要与接口中抽象 方法的参数列表一致。②方法的返回值即为构造器对应类的对象。

```Java
class Person{
   public Person(String name,int age) {
        this.name = name;
        this.age = age;
    }
    public Person(String name) {
        this.name = name;
        this.age = 0;
    }
    public Person(int age) {
        this.name = "name";
        this.age = age;
    }
}
@FunctionalInterface
public interface MyInterface<X,Y,Z>{
    public Z method(X x,Y y);
}
public void test(){
	Function<Integer,Person> fuc1 = age -> new Person(age);
    fuc1 = Person::new;
    Function<String,Person> fuc2 = name -> new Person(name);
    fuc2 = Person::new;
    MyInterface<String,Integer,Person> fuc3 = (name,age) -> new Person(name,age);
    fuc3 = Person::new;
    System.out.println(fuc1.apply(13));
    System.out.println(fuc2.apply("Tom"));
    System.out.println(fuc3.method("Jerry",12));
}
```

### 数组引用

把数组看做是一个特殊的类即可。

### Stream API

【概念】

用途：指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种 高效且易于使用的处理数据的方式。

Stream关注的是对数据的运算，与CPU打交道；集合关注的是数据的存储，与内存打交道。

①Stream 自己不会存储元素。
②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。
③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。【执行终止操作就开始执行中间操作链，并产生结果】

Stream 执行流程：① Stream的实例化② 一系列的中间操作（过滤、映射、...)③ 终止操作

【Stream的实例化】

```Java
//方式一：通过集合
List<Person> personList = PersonData.getPersonList();
Stream<Person> streamPerson = personList.stream();
Stream<Person> parallelStreamPerson = personList.parallelStream();

//方式二：通过数组
int array[] = new int[]{1,2,3,4,5,6,7,8,9,0};
//Stream<Integer> streamInteger = Arrays.stream(array);
IntStream streamInteger = Arrays.stream(array);

//方式三：通过Stream的of()
Stream<Integer> stream = Stream.of(1,2,3,4,5,6,7,8,9,0);

//方式四：创建无限流(使用迭代器+lambda表达式产生无限个数)
Stream.iterate(1,t -> t+2).limit(20).forEach(System.out::print);
//解析：iterate形参有seed和函数式接口UnaryOperator
//而UnaryOperator为public interface UnaryOperator<T> extends Function<T, T>
//那么t -> t+2 就是不断返回偶数。
//forEach为中止操作，参数为Consumer函数式接口。通过方法引用
//limit为中间操作，限制结果个数
```

【Stream中间操作】

多个中间操作可以连接起来形成一个流水线 ，除非流水线上触发终止操作，否则 中间操作不会执行任何的处理 ！

1、筛选与切片

2、映射

3、排序

【Stream终止操作】

1、匹配与查找

2、归约

3、收集

### Optional类

空指针异常是导致 Java 应用程序失败的最常见原因。Google 公司著名的 Guava 项目引入了 Optional 类。

Optional<T> 类 (java.util.Optional) 是一个容器类 它可以保存类型 T 的值， 代表这个值存在。

【创建 Optional 类对象】

```Java
Optional.of(T t) : 创建一个 Optional 实例，t必须非空；
Optional.empty() : 创建一个空的 Optional 实例
Optional.ofNullable(T t)：t可以为null
```

【判断 Optional 容器中是否包含对象】

【获取 Optional 容器的对象】

## Java9

从此版本开始，以时间驱动(6个月为周期)发布模式。

核心特性：模块化系统、jshell

语法改进：钻石操作符的使用升级、try 语句改进、接口私有方法、快速创建只读集合、InputStream的新方法tranferTo()

其他特性：JDK目录变更、String 存储结构变更、增强Stream API、Optional获取Stream、HTTP Client类

钻石操作

```Java
//钻石操作符与匿名内部类在java 8中不能共存。在java9可以。
Comparator<Object> com = new Comparator<>() {
    @Override
    public int compare(Object o1, Object o2) {
        return 0;
    }
};
```

try操作的升级

```Java
//java 8中资源关闭操作: Java 8 中，可以实现资源的自动关闭。要求自动关闭的资源的实例化必须放在try的一对小括号中
try(InputStreamReader reader = new InputStreamReader(System.in)){
	char[] cbuf = new char[20];
	int len;
	if((len = reader.read(cbuf) )!= -1){
		String str = new String(cbuf,0,len);
		System.out.println(str);
	}
} catch ( IOException e) {
	e.printStackTrace();
}

//java9中资源关闭操作：需要自动关闭的资源的实例化可以放在try的一对小括号外。
//此时的资源属性是常量，声明为final的，不可修改
InputStreamReader reader = new InputStreamReader(System.in);
try (reader) {
    char[] cbuf = new char[20];
    int len;
    if((len = reader.read(cbuf) )!= -1){
        String str = new String(cbuf,0,len);
        System.out.println(str);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

【其他略】

## Java10

核心特性：局部变量类型推断、集合新增创建不可变集合的方法

【局部变量类型推断】

声明变量时，根据所附的值，推断变量的类型

局部变量不赋值，就不能实现类型推断
​	lambda、方法引用和数组静态初始化中，左边不能声明为var
​	没有初始化的局部变量声明
​	catch块
​	方法的返回类型、参数类型，构造器参数类型，属性

【集合中新增的copyOf()，用于创建一个只读的集合】

## Java11

JDK 11 是一个长期支持版本 LTS (Long Term Support)。每三个版本一个长期版本。

JDK 11 引入了两种新的 GC。其中包括也许是划时代意义的 ZGC（虽然其目前还是实验特性）

方法改进：新增一系列字符串处理方法、Optional加强、局部变量类型推断升级（var）、HttpClient升级

底层改进：更简化的编译运行程序、废弃Nashorn 引擎、ZGC

【String中新增的方法】

略

【Optional新增的方法】

略

【局部变量类型推断的升级】

略

使用var的好处是在使用lambda表达式时给参数加上注解。

【HttpClient替换原有的HttpURLConnection】

略

## Java12



## Java13



## Java14



## Java15



## Java16



## Java17



